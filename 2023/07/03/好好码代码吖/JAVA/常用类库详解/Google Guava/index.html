<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="will"><meta name="keywords" content="will"><meta name="description" content="简介Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I&#x2F;O 等等。 所有这些工具"><meta property="og:type" content="article"><meta property="og:title" content="Google Guava"><meta property="og:url" content="https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/07/03/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/JAVA/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93%E8%AF%A6%E8%A7%A3/Google%20Guava/index.html"><meta property="og:site_name" content="Will"><meta property="og:description" content="简介Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 [collections] 、缓存 [caching] 、原生类型支持 [primitives support] 、并发库 [concurrency libraries] 、通用注解 [common annotations] 、字符串处理 [string processing] 、I&#x2F;O 等等。 所有这些工具"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2023-07-03T07:55:32.429Z"><meta property="article:modified_time" content="2023-07-23T12:38:13.852Z"><meta property="article:author" content="will"><meta property="article:tag" content="工具类"><meta property="article:tag" content="常用开发库"><meta property="article:tag" content="Google Guava"><meta name="twitter:card" content="summary_large_image"><title>Google Guava - Will</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"github.com",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>WILL</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Google Guava"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-07-03 15:55" pubdate>2023年7月3日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 27k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 229 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Google Guava</h1><div class="markdown-body"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Guava工程包含了若干被Google的 Java项目广泛依赖 的核心库，例如：集合 <code>[collections]</code> 、缓存<code>[caching]</code> 、原生类型支持 <code>[primitives support]</code> 、并发库<code>[concurrency libraries]</code> 、通用注解<code>[common annotations]</code> 、字符串处理<code>[string processing]</code> 、<code>I/O</code> 等等。 所有这些工具每天都在被Google的工程师应用在产品服务中。</p><p>guava的优点：</p><ul><li>高效设计良好的API，被Google的开发者设计，实现和使用</li><li>遵循高效的java语法实践</li><li>使代码更刻度，简洁，简单</li><li>节约时间，资源，提高生产力</li></ul><h1 id="推荐网址"><a href="#推荐网址" class="headerlink" title="推荐网址"></a>推荐网址</h1><ul><li><a href="https://github.com/google/guava/wiki/Home">Guava Wiki</a></li><li><a target="_blank" rel="noopener" href="https://guava.dev/releases/snapshot-jre/api/docs/">Guava API Doc</a></li><li><a href="https://github.com/google/guava">Guava Github</a></li><li><a target="_blank" rel="noopener" href="http://ifeve.com/google-guava/">Guava 中文教程 - ifeve.com</a></li></ul><h1 id="使用Guava"><a href="#使用Guava" class="headerlink" title="使用Guava"></a>使用Guava</h1><blockquote><p>注意：JDK 1.8 or higher.</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>28.2-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- or, for Android: --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>28.2-android<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="内容简介"><a href="#内容简介" class="headerlink" title="内容简介"></a>内容简介</h1><h2 id="基本工具-Basic-utilities"><a href="#基本工具-Basic-utilities" class="headerlink" title="基本工具 [Basic utilities]"></a>基本工具 <code>[Basic utilities]</code></h2><p>让使用Java语言变得更舒适</p><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><blockquote><p>使用和避免null：null是模棱两可的，会引起令人困惑的错误，有些时候它让人很不舒服。很多Guava工具类用快速失败拒绝null值，而不是盲目地接受</p></blockquote><p>Optional类是Java8为了解决null值判断问题，借鉴google guava类库的Optional类而引入的一个同名Optional类，使用Optional类可以避免显式的null值判断（null的防御性检查），避免null导致的NPE（NullPointerException）。</p><p>这里讲的optional 也是指jdk中的optional，其实二者类似，但是编码使用gauva的optional，阿里巴巴编程规范会提醒换成jdk自带的optional。</p><p>这里强调一下Optional的用法。</p><ul><li><strong>不要用isPressent判断一个对象是否为空</strong><br>这种用法不但没有减少null的防御性检查，而且增加了Optional包装的过程，违背了Optional设计的初衷，因此开发中要避免这种糟糕的使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">TestEnum</span> &#123;<br>    <span class="hljs-comment">/***</span><br><span class="hljs-comment">     * 编号和对应的名称</span><br><span class="hljs-comment">     */</span><br>    a(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;aname&quot;</span>),<br>    b(<span class="hljs-string">&quot;bbbb&quot;</span>, <span class="hljs-string">&quot;bname&quot;</span>),<br>    c(<span class="hljs-string">&quot;cccc&quot;</span>, <span class="hljs-string">&quot;cname&quot;</span>),<br>    ;<br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> String code;<br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    TestEnum(String code, String name) &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getNameByCod</span><span class="hljs-params">(String code)</span> &#123;<br>        Optional&lt;String&gt; nameOfCode = Arrays.stream(TestEnum.values())<br>                .filter(item -&gt; StringUtils.equals(item.code, code))<br>                .map(TestEnum::getName)<br>                .findFirst();<br>        <span class="hljs-comment">//不要这样使用optional 这样optional的意义：优雅的处理空指针 就不存在了</span><br>        <span class="hljs-keyword">if</span> (nameOfCode.isPresent()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;不存在&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 请使用orElseThrow 和orElse</span><br>        <span class="hljs-keyword">return</span> nameOfCode.orElseThrow(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;不存在&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>考虑让方法返回optional</strong></li></ul><p>《Effective Java》中对方法返回Optional的一些观点:</p><ul><li>容器（包括，集合，映射，数组，stream，optional）都不应该包装在Optional进行返回，返回空的容器能让客户端免于处理一个Optional</li><li>如果无法返回结果，且没有返回结果客户端必须进行特殊的处理，那么就应该声明返回optional</li><li>返回optional并不是一个不需要成本的操作，无论返回空，还是非空，使用optional作为返回值的方法都是需要初始化的，所以optional在看重性能的情况下使用不当是一种性能的浪费</li><li>永远不要返回基本类型对于包装类型的Optional，这需要进行基本类型-&gt;包装类型-&gt;optional的三层包装，可以使用OptionalInt，optionallong等。</li></ul><h3 id="PreConditions前置条件检查"><a href="#PreConditions前置条件检查" class="headerlink" title="PreConditions前置条件检查"></a>PreConditions前置条件检查</h3><p>前置条件: 让方法中的条件检查更简单</p><p>根据参数分为三种：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>没有额外参数</td><td>抛出的异常中没有错误消息</td></tr><tr><td>有一个Object对象作为额外参数</td><td>抛出的异常使用Object.toString() 作为错误消息</td></tr><tr><td>有一个String对象作为额外参数，并且有一组任意数量的附加Object对象</td><td>这个变种处理异常消息的方式有点类似printf，但考虑GWT的兼容性和效率，只支持%s指示符。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">test1</span><span class="hljs-params">(Integer index, List&lt;String&gt;list)</span>&#123;<br>    <span class="hljs-keyword">if</span> (Objects.isNull(index))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;index不可以为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(list))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;list不可以为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (index&lt;<span class="hljs-number">0</span>||index&gt;=list.size())&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(String.format(<span class="hljs-string">&quot;越界无法获取，下标%S&quot;</span>,index));<br>    &#125;<br>    <span class="hljs-keyword">return</span> list.get(index);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">test2</span><span class="hljs-params">(Integer index, List&lt;String&gt;list)</span>&#123;<br>    Preconditions.checkNotNull(index,<span class="hljs-string">&quot;index不可以为空&quot;</span>);<br>    Preconditions.checkNotNull(list,<span class="hljs-string">&quot;list不可以为空&quot;</span>);<br>    Preconditions.checkElementIndex(index,list.size(),String.format(<span class="hljs-string">&quot;越界无法获取，下标%S&quot;</span>,index));<br>    Preconditions.checkArgument(index &gt;= <span class="hljs-number">0</span>&amp;&amp;index&lt;list.size(),<span class="hljs-string">&quot;越界无法获取，下标%S&quot;</span>,index);<br>    <span class="hljs-keyword">return</span> list.get(index);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>test1 缺点：if看起来臃肿，优点：可用抛出我们系统的自定义异常便于前端反馈<br>test2 优点：简单直接，缺点：抛出的都是jdk中的异常，通一异常处理可能无法返回正确提示的通一结果集给前端<br>我们可用写一个带异常Class的工具类或者直接代理guava中的Predition 加一层try catch 使我其抛出我们系统的自定义异常。</p><h3 id="ComparisonChain和Ordering"><a href="#ComparisonChain和Ordering" class="headerlink" title="ComparisonChain和Ordering"></a>ComparisonChain和Ordering</h3><p>想象一个场景，人先根据age排序后根据height排序</p><h4 id="实现comparable"><a href="#实现comparable" class="headerlink" title="实现comparable"></a>实现comparable</h4><p>这是常规写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;People&gt; &#123;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Integer height;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(People o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!Objects.equals(<span class="hljs-built_in">this</span>.age, o.age)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age - o.age;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.height - o.height;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">People</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> People.builder().build();<br>        <span class="hljs-type">People</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> People.builder().build();<br>        List&lt;People&gt; list = Arrays.asList(p1, p2);<br>        Collections.sort(list);<br>        System.out.println(list);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//你或许会写得更高级一点 如下</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(People o)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ageCompare</span> <span class="hljs-operator">=</span> Ints.compare(<span class="hljs-built_in">this</span>.age, o.age);<br>        <span class="hljs-keyword">if</span> (ageCompare==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> Ints.compare(<span class="hljs-built_in">this</span>.height, o.height);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> ageCompare;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>上述代码缺点：</p><ul><li>写法繁琐</li><li>忽略了空指针， return this.age - o.age; 这一句存在空指针的情况，对null进行拆箱直接NPE（NullPoint Exception，及空指针异常）</li><li>维护复杂，再加一个存款，加逻辑复杂。</li></ul><h4 id="JAVA8使用Stream进行操作"><a href="#JAVA8使用Stream进行操作" class="headerlink" title="JAVA8使用Stream进行操作"></a>JAVA8使用Stream进行操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(People o)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">thisAge</span> <span class="hljs-operator">=</span> Optional.ofNullable(<span class="hljs-built_in">this</span>.age).orElse(Integer.MAX_VALUE);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">thisHeight</span> <span class="hljs-operator">=</span> Optional.ofNullable(<span class="hljs-built_in">this</span>.height).orElse(Integer.MAX_VALUE);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oAge</span> <span class="hljs-operator">=</span> Optional.ofNullable(o.age).orElse(Integer.MAX_VALUE);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oHeight</span> <span class="hljs-operator">=</span> Optional.ofNullable(o.height).orElse(Integer.MAX_VALUE);<br>    <span class="hljs-keyword">if</span> (thisAge!=oAge)&#123;<br>        <span class="hljs-keyword">return</span> thisAge-oAge;<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> thisHeight - oHeight;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码，规避了NPE,但是缺点依旧存在：</p><ul><li>Stream复杂的写法，导致语法不明显，逻辑不通俗易懂。</li><li>维护复杂，如果增加条件则需要变更方法。</li></ul><h4 id="ComparisonChain"><a href="#ComparisonChain" class="headerlink" title="ComparisonChain"></a>ComparisonChain</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(People o)</span> &#123;  <br>    <span class="hljs-keyword">return</span> ComparisonChain.start()  <br>            .compare(<span class="hljs-built_in">this</span>.getAge(), o.getAge(), Ordering.natural().nullsFirst())  <br>            .compare(<span class="hljs-built_in">this</span>.getHeight(), o.getHeight(), Ordering.natural().nullsFirst())  <br>            .result();  <br>&#125;<br></code></pre></td></tr></table></figure><p>优点：</p><ul><li>优雅的处理空指针，传入比较器 Ordering.natural().nullsFirst() 让null在最前面</li><li>语义化明显：先比较age 后比较 height，null在最前面</li><li>更易于维护，只需要加一行</li></ul><h4 id="Ordering"><a href="#Ordering" class="headerlink" title="Ordering"></a>Ordering</h4><p>Ordering是Guava流畅风格比较器Comparator的实现，它可以用来构建复杂的比较器，以完成排序的功能。</p><p>从实现上说Ordering实例就是一个特殊的Comparator实例。Ordering把很多基于Comparator的静态方法比如</p><p>Collections.max包装成自己的实例方法(非静态方法)，并且提供了链式调用方法，来定制和增强现有的比较器。</p><h5 id="创建排序器"><a href="#创建排序器" class="headerlink" title="创建排序器"></a>创建排序器</h5><p>常见的排序器可以由下面的静态方法创建</p><ul><li>natural()</li></ul><p>对可排序类型做自然排序，如数字按照大小，日期按照先后顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Lists.newArrayList(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);<br>    list.sort(Ordering.natural());<br>    System.out.println(list.toString());<span class="hljs-comment">//[1, 3, 5, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><ul><li>usingToString()</li></ul><p>按对象的字符串形式做字典排序，即使用toString()返回的字符串按字典顺序进行排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; stringList = Lists.newArrayList(<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-string">&quot;wangwu&quot;</span>);<br>        Collections.sort(stringList,Ordering.usingToString());<br>        System.out.println(stringList.toString());<span class="hljs-comment">//[lisi, wangwu, zhangsan]</span><br>        list.sort(Ordering.usingToString());<br>        System.out.println(list.toString());<span class="hljs-comment">//[1, 3, 5, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><ul><li>from()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">zhangsan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Company</span>());<br><span class="hljs-type">User</span> <span class="hljs-variable">lisi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-number">30</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Company</span>());<br>List&lt;User&gt; users =  Lists.newArrayList(zhangsan,lisi);<br><span class="hljs-comment">//按照age字段进行排序</span><br>Ordering&lt;User&gt; ordering1 = Ordering.from(Comparator.comparingInt(u -&gt; u.getAge()));<br>users.sort(ordering1);<br>System.out.println(users.toString());<br></code></pre></td></tr></table></figure></li></ul><h5 id="链式调用方法"><a href="#链式调用方法" class="headerlink" title="链式调用方法"></a>链式调用方法</h5><ul><li><p>reverse()<br>获取语义相反的排序器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Lists.newArrayList(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>);<br>list.sort(Ordering.natural().reverse());<br>System.out.println(list.toString());<span class="hljs-comment">//[9, 8, 7, 6, 5, 3, 1]</span><br></code></pre></td></tr></table></figure></li><li><p>nullsFirst()<br>使用当前排序器，但额外把null值排到最前面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list1 = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">//Collections.sort(list1); // 出现异常...</span><br>Collections.sort(list1, Ordering.natural().nullsFirst());<br>System.out.println(list1);<span class="hljs-comment">//[null, 1, 2, 3, 5, 8]</span><br></code></pre></td></tr></table></figure></li><li><p>nullsLast()<br>使用当前排序器，但额外把null值排到最后面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list2 = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">//Collections.sort(list1); // 出现异常...</span><br>Collections.sort(list1, Ordering.natural().nullsLast());<br>System.out.println(list1);<span class="hljs-comment">//[1, 2, 3, 5, 8, null]</span><br></code></pre></td></tr></table></figure></li><li><p>compound(Comparator)<br>成另一个比较器，以处理当前排序器中的相等情况</p></li></ul><p>首先按照年龄进行排序，如果年龄相同则按照薪水排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;UserPojo&gt; objectComparator = Comparator.comparingInt(u -&gt; u.getAge());<br>        Comparator&lt;UserPojo&gt; objectComparator2 = Comparator.comparing(u -&gt; u.getSalary());<br>        Ordering&lt;UserPojo&gt; ordering1 = Ordering.from(objectComparator).compound(objectComparator2);<br>        <span class="hljs-type">UserPojo</span> <span class="hljs-variable">zhangsan</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserPojo</span>(<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-number">20</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Company</span>(),<span class="hljs-number">1000</span>);<br>        <span class="hljs-type">UserPojo</span> <span class="hljs-variable">lisi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserPojo</span>(<span class="hljs-string">&quot;李四&quot;</span>,<span class="hljs-number">30</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Company</span>(),<span class="hljs-number">2000</span>);<br>        <span class="hljs-type">UserPojo</span> <span class="hljs-variable">wangwu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserPojo</span>(<span class="hljs-string">&quot;王五&quot;</span>,<span class="hljs-number">30</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Company</span>(),<span class="hljs-number">3000</span>);<br>        <span class="hljs-type">UserPojo</span> <span class="hljs-variable">amao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserPojo</span>(<span class="hljs-string">&quot;杨猫&quot;</span>,<span class="hljs-number">30</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Company</span>(),<span class="hljs-number">4000</span>);<br>        List&lt;UserPojo&gt; users =  Lists.newArrayList(zhangsan,lisi,wangwu,amao);<br>        users.sort(ordering1);<br>        <span class="hljs-comment">//[UserPojo(name=张三, age= 20,company=Company(name=null, address=null), salary=1000), UserPojo(name=李四, age= 30,company=Company(name=null, address=null), salary=2000), UserPojo(name=王五, age= 30,company=Company(name=null, address=null), salary=3000), UserPojo(name=杨猫, age= 30,company=Company(name=null, address=null), salary=4000)]</span><br>        System.out.println(users.toString());<br></code></pre></td></tr></table></figure><ul><li>onResultOf(Function)<br>把比较器的元素使用Function函数转化成一个值result，再对这个值应用Ordering的比较方法。result的排序顺序就是最后的排序顺序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;UserPojo&gt; users2 =  Lists.newArrayList(zhangsan,lisi,wangwu,amao,<span class="hljs-literal">null</span>);<br>        Ordering&lt;UserPojo&gt; fOrdering = Ordering.natural().onResultOf(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>&lt;UserPojo, Comparable&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-meta">@Nullable</span> Comparable <span class="hljs-title function_">apply</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> UserPojo userPojo)</span> &#123;<br>                <span class="hljs-keyword">return</span> userPojo.getSalary();<br>            &#125;<br>        &#125;).nullsFirst();<br>        users2.sort(fOrdering);<br>        <span class="hljs-comment">//[null, UserPojo(name=张三, age= 20,company=Company(name=null, address=null), salary=1000), UserPojo(name=李四, age= 30,company=Company(name=null, address=null), salary=2000), UserPojo(name=王五, age= 30,company=Company(name=null, address=null), salary=3000), UserPojo(name=杨猫, age= 30,company=Company(name=null, address=null), salary=4000)]</span><br>        System.out.println(users2.toString());<br></code></pre></td></tr></table></figure></li></ul><p>注意</p><blockquote><p>注意链式排序器的调用顺序–从右往左的顺序，上面Ordering.natural().onResultOf().nullsFirst();<br>先调用apply方法获取salary值，并把salary为null的元素放到最前面，然后把剩下的进行自然排序<br>所以如果将nullsFirst放在onResultOf的左边则会报异常</p></blockquote><h5 id="运用排序器"><a href="#运用排序器" class="headerlink" title="运用排序器"></a>运用排序器</h5><ul><li><p>greatestOf(Iterable iterable,int k)<br>获取可迭代对象中最大的k个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; result = Ordering.natural().greatestOf(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)),<span class="hljs-number">2</span>);<br>       System.out.println(result);<span class="hljs-comment">//[5, 4]</span><br></code></pre></td></tr></table></figure></li><li><p>leastOf(Iterable iterable,int k)<br>对元素按照从小到大排序，并返回前k个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; result1 = Ordering.natural().leastOf(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)),<span class="hljs-number">2</span>);<br>System.out.println(result1);<span class="hljs-comment">//[1, 2]</span><br></code></pre></td></tr></table></figure></li><li><p>isOrdered(Iterable)<br>判断可迭代对象是否已按照排序器排序:允许有排序值相等的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>Collections.sort(list);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> Ordering.natural().isOrdered(list);<br>System.out.println(order);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure></li><li><p>sortedCopy(Iterable)<br>返回一个新的已经排序的列表，原来的列表顺序不会变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>));<br>List&lt;Integer&gt; resultCopy = Ordering.natural().sortedCopy(nums);<br>System.out.println(resultCopy); <span class="hljs-comment">// [1, 3, 4]</span><br>System.out.println(nums); <span class="hljs-comment">// [4, 1, 3]</span><br></code></pre></td></tr></table></figure></li><li><p>min(E,E,…)<br>返回最小值，如果有多个，则返回第一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Ordering.natural().min(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>);<br>System.out.println(min);<br></code></pre></td></tr></table></figure></li><li><p>max(E,E,…)<br>返回最大值，如果有多个，则返回第一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> Ordering.natural().max(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>);<br>System.out.println(max)<br></code></pre></td></tr></table></figure></li></ul><h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><p>使用场景：</p><p>如定义一系列状态比如吃饭，睡觉，过马路，需要根据这个状态判断是否可以玩手机，可以在类中定义集合包装这个三个状态，如果当前状态属于三个之一那么不可以玩手机，你可以使用基本的hashset，但是hashset的元素可以被更改，导致可能方法的判断和原本的语义出现出入</p><p>优点</p><p>当对象被不可信的库调用时，不可变形式是安全的；<br>不可变对象被多个线程调用时，不存在竞态条件问题<br>不可变集合不需要考虑变化，因此可以节省时间和空间。所有不可变的集合都比它们的可变 形式有更好的内存利用率（分析和测试细节）；<br>不可变对象因为有固定不变，可以作为常量来安全使用</p><h3 id="新集合类型"><a href="#新集合类型" class="headerlink" title="新集合类型"></a>新集合类型</h3><h4 id="Multiset"><a href="#Multiset" class="headerlink" title="Multiset"></a>Multiset</h4><p>可以用两种方式看待Multiset：</p><ul><li>没有元素顺序限制的ArrayList<br>当把Multiset看成普通的Collection时，它表现得就像无序的ArrayList<ul><li>add(E)添加单个给定元素</li><li>iterator()返回一个迭代器，包含Multiset的所有元素（包括重复的元素）</li><li>size()返回所有元素的总个数（包括重复的元素）</li><li>Map&lt;E, Integer&gt;，键为元素，值为计数0</li></ul></li><li>Multiset看作Map&lt;E, Integer&gt;时，它也提供了符合性能期望的查询操作：<br>- count(Object)返回给定元素的计数。HashMultiset.count的复杂度为O(1)，TreeMultiset.count的复杂度为O(log n)。<br>- entrySet()返回Set&lt;Multiset.Entry&gt;，和Map的entrySet类似。<br>- elementSet()返回所有不重复元素的Set，和Map的keySet()类似。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiSetTest</span> &#123;<br><br>    <span class="hljs-comment">/****</span><br><span class="hljs-comment">     * java 8 一下</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title function_">statisticsWordCount1</span><span class="hljs-params">(List&lt;String&gt; list)</span> &#123;<br>        Map&lt;String, Integer&gt; countMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (list == <span class="hljs-literal">null</span> || list.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> countMap;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (String s : list) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nowCount</span> <span class="hljs-operator">=</span> countMap.getOrDefault(s, <span class="hljs-number">0</span>);<br>            countMap.put(s, nowCount + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> countMap;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * java 8</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title function_">statisticsWordCount2</span><span class="hljs-params">(List&lt;String&gt; list)</span> &#123;<br>        list = Optional.ofNullable(list).orElse(Collections.emptyList());<br>        <span class="hljs-keyword">return</span> list.stream()<br>                .collect(Collectors.groupingBy(t -&gt; t,<br>                        Collectors.reducing(<span class="hljs-number">0</span>, num -&gt; <span class="hljs-number">1</span>, Integer::sum)));<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * guava api</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title function_">statisticsWordCount3</span><span class="hljs-params">(List&lt;String&gt; list)</span> &#123;<br>        list = Optional.ofNullable(list).orElse(Collections.emptyList());<br>        HashMultiset&lt;String&gt; multiset = HashMultiset.create(list);<br>        System.out.println(multiset);<br>        <span class="hljs-keyword">return</span> multiset.stream()<br>                .collect(Collectors.toMap(item -&gt; item, multiset::count, BinaryOperator.maxBy(Ordering.natural())));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, Integer&gt; map = statisticsWordCount3(Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>));<br>        map.forEach((k, v) -&gt; System.out.println(k + <span class="hljs-string">&quot;-&quot;</span> + v));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SortedMultiset"><a href="#SortedMultiset" class="headerlink" title="SortedMultiset"></a>SortedMultiset</h4><p>Multiset 接口的变种，它支持高效地获取指定范围的子集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortMultiSetTest</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在不改变源money 元素的情况下 统计介于min和max间的钱</span><br><span class="hljs-comment">     * money中的null 视为0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Float&gt; <span class="hljs-title function_">findMoneyBetween1</span><span class="hljs-params">(<span class="hljs-type">float</span> min, <span class="hljs-type">float</span> max, List&lt;Float&gt; money)</span> &#123;<br>        money = Optional.ofNullable(money).orElse(Collections.emptyList());<br>        <span class="hljs-keyword">return</span> money.stream().map(item -&gt; Optional.ofNullable(item).orElse(<span class="hljs-number">0F</span>))<br>                .filter(item -&gt; item &gt; min &amp;&amp; item &lt; max)<br>                .collect(Collectors.toList());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在不改变源money 元素的情况下 统计介于min和max间的钱</span><br><span class="hljs-comment">     * money中的null 视为0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Float&gt; <span class="hljs-title function_">findMoneyBetween2</span><span class="hljs-params">(<span class="hljs-type">float</span> min, <span class="hljs-type">float</span> max, List&lt;Float&gt; money)</span> &#123;<br>        money = Optional.ofNullable(money).orElse(Collections.emptyList());<br>        TreeMultiset&lt;Float&gt; treeMultiset = TreeMultiset.create(Ordering.&lt;Float&gt;natural().onResultOf(f1 -&gt; Optional.ofNullable(f1).orElse(<span class="hljs-number">0F</span>)));<br>        treeMultiset.addAll(money);<br>        <span class="hljs-keyword">return</span> Lists.newLinkedList(treeMultiset.subMultiset(min, BoundType.CLOSED, max, BoundType.CLOSED));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Multimap"><a href="#Multimap" class="headerlink" title="Multimap"></a>Multimap</h4><p>Guava的 Multimap可以很容易地把一个键映射到多个值。换句话说，Multimap是把键映射到任意多个值的一般方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Collection&lt;Integer&gt;&gt; <span class="hljs-title function_">mergeMap1</span><span class="hljs-params">(Map&lt;String, Integer&gt; map1, Map&lt;String, Integer&gt; map2)</span> &#123;<br>    map1 = Optional.ofNullable(map1).orElse(Collections.emptyMap());<br>    map2 = Optional.ofNullable(map2).orElse(Collections.emptyMap());<br>    Set&lt;String&gt; allKey = Stream.of(map1.keySet(), map2.keySet()).flatMap(Collection::stream).collect(Collectors.toSet());<br>    Map&lt;String, Collection&lt;Integer&gt;&gt; resMap = Maps.newHashMap();<br>    <span class="hljs-keyword">for</span> (String key : allKey) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer1</span> <span class="hljs-operator">=</span> map1.get(key);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer2</span> <span class="hljs-operator">=</span> map2.get(key);<br>        Set&lt;Integer&gt; tempSet = Sets.newHashSet();<br>        <span class="hljs-keyword">if</span> (Objects.nonNull(integer1)) &#123;<br>            tempSet.add(integer1);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (Objects.nonNull(integer2)) &#123;<br>            tempSet.add(integer2);<br>        &#125;<br>        resMap.put(key, tempSet);<br>    &#125;<br>    <span class="hljs-keyword">return</span> resMap;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Collection&lt;Integer&gt;&gt; <span class="hljs-title function_">mergeMap2</span><span class="hljs-params">(Map&lt;String, Integer&gt; map1, Map&lt;String, Integer&gt; map2)</span> &#123;<br>    map1 = Optional.ofNullable(map1).orElse(Collections.emptyMap());<br>    map2 = Optional.ofNullable(map2).orElse(Collections.emptyMap());<br>    Multimap&lt;String, Integer&gt; multimap = HashMultimap.create();<br>    map1.forEach(multimap::put);<br>    map2.forEach(multimap::put);<br>    <span class="hljs-keyword">return</span> multimap.asMap();<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="BiMap"><a href="#BiMap" class="headerlink" title="BiMap"></a>BiMap</h4><p>BiMap是特殊的Map：</p><ul><li>可以用 inverse()反转BiMap&lt;K, V&gt;的键值映射</li><li>保证值是唯一的，因此 values()返回Set而不是普通的Collection</li><li>在BiMap中，如果你想把键映射到已经存在的值，会抛出IllegalArgumentException异常。如果对特定值，你想要强制替换它的键，请使用 BiMap.forcePut(key, value)。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BiMapLearn</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//想象这是用户id 和用户名对应map</span><br>        <span class="hljs-comment">//你需要根据id查询用户名。根据用户名查询id（用户名同样不可以重复）</span><br>        HashBiMap&lt;String, String&gt; userNameAndIdMap = HashBiMap.create();<br>        userNameAndIdMap.put(<span class="hljs-string">&quot;2017015600&quot;</span>,<span class="hljs-string">&quot;陈兴cupk&quot;</span>);<br>        userNameAndIdMap.put(<span class="hljs-string">&quot;80309525&quot;</span>,<span class="hljs-string">&quot;陈兴cmbnk&quot;</span>);<br>        <span class="hljs-comment">// 重复value 会抛出异常ava.lang.IllegalArgumentException:</span><br>        <span class="hljs-comment">// value already present: 陈兴cmbnk</span><br><span class="hljs-comment">//        userNameAndIdMap.put(&quot;309525&quot;,&quot;陈兴cmbnk&quot;);</span><br>        <span class="hljs-comment">//forcePut 可以强制替换 key -value 组合</span><br><span class="hljs-comment">//        userNameAndIdMap.forcePut(&quot;309525&quot;,&quot;陈兴cmbnk&quot;);</span><br>        System.out.println(userNameAndIdMap.get(<span class="hljs-string">&quot;2017015600&quot;</span>));<br>        System.out.println(userNameAndIdMap.inverse().get(<span class="hljs-string">&quot;陈兴cmbnk&quot;</span>));<br>        System.out.println(userNameAndIdMap.get(<span class="hljs-string">&quot;80309525&quot;</span>));<br>        <span class="hljs-comment">//set类型的key value</span><br>        Set&lt;String&gt; strings = userNameAndIdMap.keySet();<br>        Set&lt;String&gt; values = userNameAndIdMap.values();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h4><p>使用场景：当你需要多个字段作为key时，你可能为这个key编写一个类，重写equals和hashMap。或者使用形同Map&lt;FirstName, Map&lt;LastName, Person&gt;&gt;的map结构，前者编码繁琐，后者使用不友好（第一个get后判空，后才能左第二次get）</p><p>Guava为此提供了新集合类型Table，它有两个支持所有类型的键：”行”和”列”。Table提供多种视图，以便你从各种角度使用它：</p><p>rowMap()：用Map&lt;R, Map&lt;C, V&gt;&gt;表现Table&lt;R, C, V&gt;。同样的， rowKeySet()返回”行”的集合Set。</p><p>row ：用Map&lt;C, V&gt;返回给定”行”的所有列，对这个map进行的写操作也将写入Table中。</p><p>类似的列访问方法：columnMap()、columnKeySet()、column。（基于列的访问会比基于的行访问稍微低效点）</p><p>cellSet()：用元素类型为Table.Cell的Set表现Table&lt;R, C, V&gt;。Cell类似于Map.Entry，但它是用行和列两个键区分的。</p><p>使用案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TableLearn</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(getNameByAgeAndNo1(<span class="hljs-number">17</span>, <span class="hljs-string">&quot;201715600&quot;</span>));<br>        System.out.println(getNameByAgeAndNo2(<span class="hljs-number">17</span>, <span class="hljs-string">&quot;201715600&quot;</span>));<br>    &#125;<br><br>	<span class="hljs-comment">//根据年龄和编号 获取名字，编写KeyOfAgeAndNo 重写equals hashcode</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getNameByAgeAndNo1</span><span class="hljs-params">(<span class="hljs-type">int</span> age,String no)</span>&#123;<br>        HashMap&lt;KeyOfAgeAndNo, String&gt; memory = Maps.newHashMap();<br>        memory.put(KeyOfAgeAndNo.of(<span class="hljs-number">17</span>,<span class="hljs-string">&quot;201715600&quot;</span>),<span class="hljs-string">&quot;大一的陈兴&quot;</span>);<br>        memory.put(KeyOfAgeAndNo.of(<span class="hljs-number">14</span>,<span class="hljs-string">&quot;0929&quot;</span>),<span class="hljs-string">&quot;高一的陈兴&quot;</span>);<br>        memory.put(KeyOfAgeAndNo.of(<span class="hljs-number">20</span>,<span class="hljs-string">&quot;80303697&quot;</span>),<span class="hljs-string">&quot;实习的陈兴&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> Optional.ofNullable(memory.get(KeyOfAgeAndNo.of(age, no)))<br>                .orElseThrow(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;查无此人&quot;</span>));<br>    &#125;<br>	<span class="hljs-comment">//编写KeyOfAgeAndNo 重写equals hashcode</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyOfAgeAndNo</span>&#123;<br>        Integer age;<br>        String no;<br>        <span class="hljs-keyword">static</span> KeyOfAgeAndNo <span class="hljs-title function_">of</span><span class="hljs-params">( Integer age,String no)</span>&#123;<br>            <span class="hljs-type">KeyOfAgeAndNo</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeyOfAgeAndNo</span>();<br>            res.age=age;<br>            res.no=no;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> KeyOfAgeAndNo)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">KeyOfAgeAndNo</span> <span class="hljs-variable">that</span> <span class="hljs-operator">=</span> (KeyOfAgeAndNo) o;<br>            <span class="hljs-keyword">return</span> Objects.equals(age, that.age) &amp;&amp;<br>                    Objects.equals(no, that.no);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> Objects.hash(age, no);<br>        &#125;<br>    &#125;<br>	<span class="hljs-comment">//使用table </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getNameByAgeAndNo2</span><span class="hljs-params">(<span class="hljs-type">int</span> age,String no)</span>&#123;<br>        HashBasedTable&lt;Integer ,String,String&gt;table=HashBasedTable.create();<br>        table.put(<span class="hljs-number">17</span>,<span class="hljs-string">&quot;201715600&quot;</span>,<span class="hljs-string">&quot;大一的陈兴&quot;</span>);<br>        table.put(<span class="hljs-number">14</span>,<span class="hljs-string">&quot;0929&quot;</span>,<span class="hljs-string">&quot;高一的陈兴&quot;</span>);<br>        table.put(<span class="hljs-number">20</span>,<span class="hljs-string">&quot;80303697&quot;</span>,<span class="hljs-string">&quot;实习的陈兴&quot;</span>);<br>        <span class="hljs-keyword">return</span> Optional.ofNullable(table.get(age, no))<br>                .orElseThrow(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;查无此人&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ClassToInstanceMap"><a href="#ClassToInstanceMap" class="headerlink" title="ClassToInstanceMap"></a>ClassToInstanceMap</h4><ul><li>使用场景，类型指向实例，使用普通map需要</li><li>示例<br>getInstanceByClass1需要进行强转因为map get方法返回object类型，不能限制key的类型<br>getInstanceByClass2则没有这种需要 且可以限定key的类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassToInstanceMapLearn</span> &#123;<br><span class="hljs-comment">//静态内部类实现单例 和ClassToInstanceMap 使用没有必要关系</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ClassToInstanceMapLearn INSTANCE;<br><br>        <span class="hljs-keyword">static</span> &#123;<br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassToInstanceMapLearn</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">ClassToInstanceMapLearn</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;ClassToInstanceMapLearn Constructor&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClassToInstanceMapLearn <span class="hljs-title function_">newInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Class&lt;?&gt;, ? <span class="hljs-built_in">super</span> ClassToInstanceMapLearn&gt; Memory1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        Memory1.put(ClassToInstanceMapLearn.class, ClassToInstanceMapLearn.newInstance());<br>        <span class="hljs-comment">//加入从 简单工场拿SingletonHolder实例 强转化 将抛出异常</span><br>        Memory1.put(SingletonHolder.class, ClassToInstanceMapLearn.newInstance());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassToInstanceMapLearn</span>&gt; T <span class="hljs-title function_">getInstanceByClass1</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> &#123;<br>        <span class="hljs-comment">//需要强转需要去判断 是否是clazz的实例 错误写法</span><br>        <span class="hljs-keyword">return</span> (T) Optional.ofNullable(Memory1.get(clazz))<br>                .orElseThrow(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;不存在&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ClassToInstanceMap&lt;? <span class="hljs-built_in">super</span> ClassToInstanceMapLearn&gt; Memory2 = MutableClassToInstanceMap.create();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        Memory2.putInstance(ClassToInstanceMapLearn.class, ClassToInstanceMapLearn.newInstance());<br>        <span class="hljs-comment">//无法加入</span><br><span class="hljs-comment">//        Memory2.put(SingletonHolder.class, ClassToInstanceMapLearn.newInstance());</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassToInstanceMapLearn</span>&gt; T <span class="hljs-title function_">getInstanceByClass2</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> &#123;<br>        <span class="hljs-comment">//不需要强转</span><br>        <span class="hljs-keyword">return</span> Optional.ofNullable(Memory2.getInstance(clazz))<br>                .orElseThrow(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;不存在&quot;</span>));<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(getInstanceByClass1(ClassToInstanceMapLearn.class));<br>         System.out.println(getInstanceByClass2(ClassToInstanceMapLearn.class));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="集合-Collections"><a href="#集合-Collections" class="headerlink" title="集合[Collections]"></a>集合<code>[Collections]</code></h2><p>Guava对JDK集合的扩展，这是Guava最成熟和为人所知的部分<br>guava 中的集合工具常常以集合名称加s出现</p><ul><li>Collections2 因为java存在Collections guava加了2</li><li>Lists</li><li>Maps</li><li>Sets<br>等等 上面介绍的新集合类型也存在对应的工具类<br>这些工具类的共性<strong>都存在静态工厂方法</strong><br>为什么要使用静态工厂方法，它相比于构造方法（这里的静态工厂方法不是指，设计模式中的工厂模式）<br>《Effective Java》第一条 使用静态工厂方法代替构造器，给予了解答</li><li>静态工厂方法有名字<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//这一句是什么意思</span><br><span class="hljs-type">BigInteger</span> <span class="hljs-variable">big1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigInteger</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">10</span>));<br>System.out.println(big1);<br><span class="hljs-comment">//这一句又是什么意思</span><br><span class="hljs-type">BigInteger</span> <span class="hljs-variable">big2</span> <span class="hljs-operator">=</span> BigInteger.probablePrime(<span class="hljs-number">10</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">10</span>));<br>System.out.println(big2);<br></code></pre></td></tr></table></figure></li><li>静态工厂方法，不必每次都生成一个对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//虽然下面两句都在放屁，但是前者的屁更臭</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br><span class="hljs-comment">//每次生成一个新对象</span><br><span class="hljs-type">Boolean</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>(flag);<br><span class="hljs-comment">//不会生成新对象</span><br><span class="hljs-type">Boolean</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> Boolean.valueOf(flag);<br></code></pre></td></tr></table></figure></li><li>静态工厂方法可以返回任何原返回类型的子类型，如guava中的api</li><li>静态工厂的返回对象的类可也随着每次调用而变化，取决于入参类似于简单工厂模式</li><li>静态工厂方法返回的对象所属的类可以在，在编写百行该静态工厂方法的类时不存在，如JDBC数据库连接</li></ul><h3 id="Collections2"><a href="#Collections2" class="headerlink" title="Collections2"></a>Collections2</h3><ul><li>过滤<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">filterLearn</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>);<br>    Collection&lt;Integer&gt; filter = Collections2.filter(list, Objects::nonNull);<br>    System.out.println(list);<br>    System.out.println(filter);<br>    <span class="hljs-comment">//返回一个继承了AbstractCollection的集合</span><br>    System.out.println(filter.getClass());<br>&#125;<br></code></pre></td></tr></table></figure></li><li>转换<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections2Test</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer nums;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Collections2Test</span><span class="hljs-params">(Integer nums)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nums = nums;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transformLearn</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Collections2Test</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Collections2Test</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">Collections2Test</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> ne <span class="hljs-title function_">Collections2Test</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span>;<br>        <span class="hljs-type">Collections2Test</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Collections2Test</span>(<span class="hljs-number">3</span>);<br>        List&lt;Collections2Test&gt; list = Arrays.asList(c1, c2, c3);<br>        Collection&lt;Integer&gt; transform = Collections2.transform(list,<br>                t -&gt; Optional.ofNullable(t)<br>                        .orElse(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Collections2Test</span>(<span class="hljs-number">0</span>)).nums);<br>        System.out.println(transform);<br>        System.out.println(transform.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>全排列<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    ArrayList&lt;Integer&gt; list = Lists.newArrayList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>    Collection&lt;List&lt;Integer&gt;&gt; lists = Collections2.orderedPermutations(list);<br>    lists.forEach(System.out::println);<br>    Collection&lt;List&lt;Integer&gt;&gt; permutations = Collections2.permutations(list);<br>    System.out.println(<span class="hljs-string">&quot;====&quot;</span>);<br>    permutations.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><ul><li>切割<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取一个字符串中的全部字符，返回不可变集合</span><br>ImmutableList&lt;Character&gt; chars = Lists.charactersOf(<span class="hljs-string">&quot;123&quot;</span>);<br>System.out.println(chars);<br><span class="hljs-comment">//按照大小分割list</span><br>ArrayList&lt;Integer&gt; intList = Lists.newArrayList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>);<br>List&lt;List&lt;Integer&gt;&gt; partitionList = Lists.partition(intList, <span class="hljs-number">2</span>);<br>System.out.println(partitionList);<br></code></pre></td></tr></table></figure></li></ul><h3 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h3><ul><li>交集<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">HashSet&lt;Integer&gt; set1 = Sets.newHashSet(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>HashSet&lt;Integer&gt; set2 = Sets.newHashSet(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">//返回交集</span><br>Sets.SetView&lt;Integer&gt; intersection = Sets.intersection(set1, set2);<br>System.out.println(intersection);<br></code></pre></td></tr></table></figure></li><li>差集<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回set1中存在 s2中不存在的元素</span><br>System.out.println(Sets.difference(set1, set2));<br>System.out.println(Sets.difference(set2, set1));<br></code></pre></td></tr></table></figure></li><li>并集<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//返回并集</span><br>Sets.SetView&lt;Integer&gt; union = Sets.union(set1, set2);<br>System.out.println(union);<br></code></pre></td></tr></table></figure></li><li>过滤<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Sets.filter(union, t -&gt; t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure></li></ul><h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><ul><li>uniqueIndex 根据传入的function生成map<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list1 = Lists.newArrayList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br><span class="hljs-comment">//传入function根据function生成map 要求 key 不可重复</span><br>ImmutableMap&lt;String, Integer&gt; integerImmutableMap = Maps.uniqueIndex(list1, String::valueOf);<br></code></pre></td></tr></table></figure></li><li>获取两个map的不同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//如果你预计hashMap的大小请使用这个方法</span><br>HashMap&lt;String, Integer&gt; map1 = Maps.newHashMapWithExpectedSize(<span class="hljs-number">3</span>);<br>map1.put(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">1</span>);<br>map1.put(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-number">2</span>);<br>map1.put(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-number">3</span>);<br>map1.put(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-number">3</span>);<br>map1.put(<span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-number">5</span>);<br>ArrayList&lt;Integer&gt; list1 = Lists.newArrayList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br><span class="hljs-comment">//传入function根据function生成map 要求 key 不可重复</span><br>ImmutableMap&lt;String, Integer&gt; integerImmutableMap = Maps.uniqueIndex(list1, String::valueOf);<br>MapDifference&lt;String, Integer&gt; difference = Maps.difference(map1, integerImmutableMap);<br><span class="hljs-comment">//左边独有key</span><br>Map&lt;String, Integer&gt; mapLeft = difference.entriesOnlyOnLeft();<br><span class="hljs-comment">//右边独有key</span><br>Map&lt;String, Integer&gt; mapRight = difference.entriesOnlyOnRight();<br><span class="hljs-comment">//两个map相同key 但是不同value</span><br>Map&lt;String, MapDifference.ValueDifference&lt;Integer&gt;&gt; valueDifferenceMap = difference.entriesDiffering();<br><span class="hljs-comment">//左边map的值 有边map的值</span><br>System.out.println(valueDifferenceMap.get(<span class="hljs-string">&quot;4&quot;</span>).rightValue());<br>System.out.println(valueDifferenceMap.get(<span class="hljs-string">&quot;4&quot;</span>).leftValue());<br></code></pre></td></tr></table></figure></li><li>过滤<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//过滤map 中的Entries</span><br>Map&lt;String, Integer&gt; filterEntriesMap = Maps.filterEntries(map1, e -&gt; &#123;<br>    <span class="hljs-keyword">assert</span> e != <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> StringUtils.equals(e.getKey(), String.valueOf(e.getValue()));<br>&#125;);<br><span class="hljs-comment">//过滤key</span><br>Map&lt;String, Integer&gt; filterKeysMap = Maps.filterKeys(map1, StringUtils::isNotBlank);<br><span class="hljs-comment">//过滤value</span><br>Map&lt;String, Integer&gt; filterValuesMap = Maps.filterValues(map1, v -&gt; &#123;<br>    <span class="hljs-keyword">assert</span> v != <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> v % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li>根据map构造转换器<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">HashBiMap&lt;String, Integer&gt; biMapForConverter = HashBiMap.create(integerImmutableMap);<br>Converter&lt;String, Integer&gt; converter = Maps.asConverter(biMapForConverter);<br>System.out.println(converter.convert(<span class="hljs-string">&quot;1&quot;</span>));<br>Iterable&lt;Integer&gt; convertRes = converter.convertAll(Arrays.asList(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>));<br></code></pre></td></tr></table></figure></li><li>转换<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; transformEntriesMap = Maps.transformEntries(map1, (key, value) -&gt; String.valueOf(map1.get(key)));<br><span class="hljs-comment">//同样还存在</span><br><span class="hljs-comment">//        Maps.transformValues()</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><h3 id="连接器-Joiner"><a href="#连接器-Joiner" class="headerlink" title="连接器[Joiner]"></a>连接器<code>[Joiner]</code></h3><p><strong>连接任何实现了Iterable结果的类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//跳过null</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> Joiner.on(<span class="hljs-string">&quot;-&quot;</span>).skipNulls().join(list);<br>System.out.println(str1);<br><span class="hljs-comment">//用NNNN代替空</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> Joiner.on(<span class="hljs-string">&quot;-&quot;</span>).useForNull(<span class="hljs-string">&quot;NNNN&quot;</span>).join(list);<br>System.out.println(str2);<br><span class="hljs-comment">//空指针</span><br>String str3= Joiner.on(<span class="hljs-string">&quot;-&quot;</span>).join(list);<br>System.out.println(str3);<br></code></pre></td></tr></table></figure><ul><li>连接map<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;String, String&gt; map = Maps.newHashMap();<br>map.put(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>);<br>map.put(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>);<br><span class="hljs-comment">//每一个k-v连接方式为\n  kv连接方式为-&gt;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> Joiner.on(<span class="hljs-string">&quot;\n&quot;</span>).withKeyValueSeparator(<span class="hljs-string">&quot;-&gt;&quot;</span>).join(map);<br>System.out.println(str1);<br></code></pre></td></tr></table></figure></li><li>连接实现了Appendable的任何类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> Joiner.on(<span class="hljs-string">&quot;-&quot;</span>).appendTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(), Arrays.asList(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>));<br>System.out.println(str3);<br></code></pre></td></tr></table></figure></li></ul><h3 id="分割器-Splitter"><a href="#分割器-Splitter" class="headerlink" title="分割器[Splitter]"></a>分割器<code>[Splitter]</code></h3><ul><li>分隔成list<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">String str=<span class="hljs-string">&quot;1-2  -3 - 4- - - &quot;</span>;<br>List&lt;String&gt; list1 = Splitter.fixedLength(<span class="hljs-number">2</span>).splitToList(str);<br>System.out.println(list1);<br>List&lt;String&gt; list2 = Splitter.on(<span class="hljs-string">&quot;-&quot;</span>).splitToList(str);<br>System.out.println(list2);<br>List&lt;String&gt; list3 = Splitter.on(<span class="hljs-string">&quot;-&quot;</span>).trimResults().splitToList(str);<br>System.out.println(list3);<br></code></pre></td></tr></table></figure></li><li>分割成map<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String str2=<span class="hljs-string">&quot;1#2-2#3-3#1&quot;</span>;<br><span class="hljs-comment">//每一组entry使用的是-分割 k和v使用的#分割</span><br>Map&lt;String, String&gt; map = Splitter.on(<span class="hljs-string">&quot;-&quot;</span>).withKeyValueSeparator(<span class="hljs-string">&quot;#&quot;</span>).split(str2);<br>map.forEach((k,v)-&gt; System.out.println(k+<span class="hljs-string">&quot;-&gt;&quot;</span>+v));<br></code></pre></td></tr></table></figure></li><li>分割成Iterable<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterable&lt;String&gt; stringIterable = Splitter.on(<span class="hljs-string">&quot;-&quot;</span>).split(str);<br>stringIterable.iterator().forEachRemaining(System.out::println);<br></code></pre></td></tr></table></figure></li></ul><h3 id="字符匹配器"><a href="#字符匹配器" class="headerlink" title="字符匹配器"></a>字符匹配器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//删除字符</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/1/2/3/4&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> CharMatcher.is(<span class="hljs-string">&#x27;/&#x27;</span>).removeFrom(str);<br>System.out.println(str1);<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> CharMatcher.anyOf(<span class="hljs-string">&quot;/1&quot;</span>).removeFrom(str);<br>System.out.println(str2);<br><span class="hljs-type">String</span> <span class="hljs-variable">str3</span> <span class="hljs-operator">=</span> CharMatcher.noneOf(<span class="hljs-string">&quot;12/&quot;</span>).removeFrom(str);<br>System.out.println(str3);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">str4</span> <span class="hljs-operator">=</span> CharMatcher.inRange(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>).removeFrom(str);<br>System.out.println(str4);<br><span class="hljs-comment">//替换</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str5</span> <span class="hljs-operator">=</span> CharMatcher.inRange(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>).replaceFrom(<span class="hljs-string">&quot;a1b2c3&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>);<br>System.out.println(str5);<br><span class="hljs-comment">//裁剪</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str6</span> <span class="hljs-operator">=</span> CharMatcher.inRange(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>).trimTrailingFrom(<span class="hljs-string">&quot;a1b2c3&quot;</span>);<br>System.out.println(str6);<br><span class="hljs-comment">//比对</span><br>System.out.println(CharMatcher.inRange(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>).matchesAllOf(<span class="hljs-string">&quot;1b2&quot;</span>));<br></code></pre></td></tr></table></figure><h3 id="字符集和大小写格式"><a href="#字符集和大小写格式" class="headerlink" title="字符集和大小写格式"></a>字符集和大小写格式</h3><ul><li>Charsets针对所有Java平台都要保证支持的六种字符集提供了常量引用。尝试使用这些常量，而不是通过名称获取字符集实例。</li><li>CaseFormat</li></ul><h2 id="缓存-Caches"><a href="#缓存-Caches" class="headerlink" title="缓存[Caches]"></a>缓存<code>[Caches]</code></h2><p>Guava Cache：本地缓存实现，支持多种缓存过期策略</p><h2 id="函数式风格-Functional-idioms"><a href="#函数式风格-Functional-idioms" class="headerlink" title="函数式风格[Functional idioms]"></a>函数式风格<code>[Functional idioms]</code></h2><p>Guava的函数式支持可以显著简化代码，但请谨慎使用它</p><h2 id="并发-Concurrency"><a href="#并发-Concurrency" class="headerlink" title="并发[Concurrency]"></a>并发<code>[Concurrency]</code></h2><p>强大而简单的抽象，让编写正确的并发代码更简单</p><ul><li>ListenableFuture：完成后触发回调的Future</li><li>Service框架：抽象可开启和关闭的服务，帮助你维护服务的状态逻辑</li></ul><h2 id="字符串处理-Strings"><a href="#字符串处理-Strings" class="headerlink" title="字符串处理[Strings]"></a>字符串处理<code>[Strings]</code></h2><p>非常有用的字符串工具，包括分割、连接、填充等操作</p><h2 id="原生类型-Primitives"><a href="#原生类型-Primitives" class="headerlink" title="原生类型[Primitives]"></a>原生类型<code>[Primitives]</code></h2><p>扩展 JDK 未提供的原生类型（如int、char）操作， 包括某些类型的无符号形式</p><h2 id="区间-Ranges"><a href="#区间-Ranges" class="headerlink" title="区间[Ranges]"></a>区间<code>[Ranges]</code></h2><p>可比较类型的区间API，包括连续和离散类型</p><h2 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><p>简化I&#x2F;O尤其是I&#x2F;O流和文件的操作，针对Java5和6版本</p><h2 id="散列-Hash"><a href="#散列-Hash" class="headerlink" title="散列[Hash]"></a>散列<code>[Hash]</code></h2><p>提供比Object.hashCode()更复杂的散列实现，并提供布鲁姆过滤器的实现</p><h2 id="事件总线-EventBus"><a href="#事件总线-EventBus" class="headerlink" title="事件总线[EventBus]"></a>事件总线<code>[EventBus]</code></h2><p>发布-订阅模式的组件通信，但组件不需要显式地注册到其他组件中</p><h2 id="数学运算-Math"><a href="#数学运算-Math" class="headerlink" title="数学运算[Math]"></a>数学运算<code>[Math]</code></h2><p>优化的、充分测试的数学工具类</p><h2 id="反射-Reflection"><a href="#反射-Reflection" class="headerlink" title="反射[Reflection]"></a>反射<code>[Reflection]</code></h2><p>Guava 的 Java 反射机制工具类</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/" class="category-chain-item">好好码代码吖</a> <span>></span> <a href="/categories/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/JAVA/" class="category-chain-item">JAVA</a> <span>></span> <a href="/categories/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/JAVA/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93%E8%AF%A6%E8%A7%A3/" class="category-chain-item">常用类库详解</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/">#工具类</a> <a href="/tags/%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%BA%93/">#常用开发库</a> <a href="/tags/Google-Guava/">#Google Guava</a></div></div><div class="license-box my-3"><div class="license-title"><div>Google Guava</div><div>https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/07/03/好好码代码吖/JAVA/常用类库详解/Google Guava/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>will</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年7月3日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2023/07/16/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/JAVA/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93%E8%AF%A6%E8%A7%A3/Hutool/" title="Hutool"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Hutool</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2023/06/26/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/JAVA/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%BA%93%E8%AF%A6%E8%A7%A3/Apache%20Common/" title="Apache Common"><span class="hidden-mobile">Apache Common</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing;(t=t.getElementById("subtitle"))&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>