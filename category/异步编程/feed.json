{
    "version": "https://jsonfeed.org/version/1",
    "title": "Will • All posts by \"异步编程\" category",
    "description": "愿你一生努力，一生被爱",
    "home_page_url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io",
    "items": [
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/31/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/JAVA/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B(2)-Java%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8C%97/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/31/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/JAVA/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B(2)-Java%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8C%97/",
            "title": "异步编程(2)-Java异步编程指北",
            "date_published": "2023-05-31T01:03:15.661Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>本文简要介绍一下Java中可支持异步编程的类和使用方法，方便后期回顾和汇总。</p>\n</blockquote>\n<h1 id=\"同步异步优缺点\"><a href=\"#同步异步优缺点\" class=\"headerlink\" title=\"同步异步优缺点\"></a>同步异步优缺点</h1><p>在我们平时开发中或多或少都会遇到需要调用接口来完成一个功能的需求，这个接口可以是内部系统也可以是外部的，然后等到接口返回数据了才能继续其他的业务流程，这就是传统的 <code>同步</code>模式。</p>\n<p>同步模式虽然简单但缺点也很明显，如果对方服务处理缓慢迟迟未能返回数据，或网络问题导致响应变长，就会阻塞我们调用方的线程，导致我们主流程的耗时的延迟，传统的解决方式是增加接口、网关的超时(timeout)设置，防止无限期等待。但即使这样还是会占用CPU资源。</p>\n<p>在我们做rpc远程调用，redis，数据库访问等比较耗时的网络请求时经常要面对这样的问题，这种业务场景我们可以引入<code>异步</code>的编程思想，即主流程不需要阻塞等待接口返回数据，而是继续往下执行，当真正需要这个接口返回结果时再通过回调或阻塞的方式获取，此时我们的主流程和异步任务是并行执行的。</p>\n<p>Java中实现异步主要是通过Future，CompletableFuture，Guava ListenableFuture以及一些异步响应式框架如RxJava实现。</p>\n<p>下面我们主要看下这几种组件适用的业务场景和需要注意的地方，避免踩坑。</p>\n<h1 id=\"Future\"><a href=\"#Future\" class=\"headerlink\" title=\"Future\"></a>Future</h1><p>Future 表示异步计算的结果。提供了检查计算是否完成、等待计算完成以及检索计算结果的方法。只有在计算完成后才能使用方法 get 检索结果，必要时阻止，直到准备就绪。取消是通过该方法 cancel 执行的。提供了其他方法来确定任务是正常完成还是已取消。计算完成后，无法取消计算。如果您想为了可取消性而使用Future ，但不提供可用的结果，则可以声明<code> Future&lt;?&gt;</code> 的类型并作为基础任务的结果返回 null。<br>接口信息如下图所示：<br><img src=\"https://s3.bmp.ovh/imgs/2023/05/31/b2baebe6d50661a8.png\"><br>实际开发中我们一般会结合线程池的submit配合使用，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">import</span> java.util.concurrent.ExecutorService;  <br><span class=\"hljs-keyword\">import</span> java.util.concurrent.Executors;  <br><span class=\"hljs-keyword\">import</span> java.util.concurrent.Future;  <br>  <br><span class=\"hljs-comment\">/**  </span><br><span class=\"hljs-comment\"> * AsyncTest 异步  </span><br><span class=\"hljs-comment\"> * <span class=\"hljs-doctag\">@author</span> will  </span><br><span class=\"hljs-comment\"> */</span><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FutureTest</span> &#123;  <br> <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception&#123;  <br>        <span class=\"hljs-comment\">//创建线程池  </span><br>        <span class=\"hljs-type\">ExecutorService</span> <span class=\"hljs-variable\">executor</span> <span class=\"hljs-operator\">=</span> Executors.newCachedThreadPool();  <br>        <span class=\"hljs-comment\">// 模拟接口调用  </span><br>        Future&lt;String&gt; submit = executor.submit(() -&gt; &#123;  <br>            Thread.sleep(<span class=\"hljs-number\">2</span>*<span class=\"hljs-number\">1000</span>);  <br>            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;hello world&quot;</span>;  <br>        &#125;);  <br>  <br>        System.out.println(<span class=\"hljs-string\">&quot;异步执行结果 = &quot;</span> + submit.get());  <br>        System.out.println(<span class=\"hljs-string\">&quot;submit.isDone() = &quot;</span> + submit.isDone());  <br>  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>\n<p>简单的说我有一个任务，提交给了Future，Future替我完成这个任务，这期间我可以去做别的事情。一段时间之后，我再从Future取出结果。</p>\n<p>上面的代码有2个地方需要注意:</p>\n<ul>\n<li>不建议使用future.get()方式，而应该使用future.get(long timeout, TimeUnit unit)<br>  尤其是在生产环境一定要设置合理的超时时间，防止程序无限期等待下去</li>\n<li>另外就是要考虑异步任务执行过程中报错抛出异常的情况，需要捕获future的异常信息。<br>通过代码可以看出一些简单的异步场景可以使用Future解决，但是对于结果的获取却不是很方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式相当于把异步变成了同步，显然和异步编程的初衷相违背，轮询的方式又会浪费CPU资源。</li>\n</ul>\n<p><code>Future没有提供通知的机制，就是回调，我们无法知道它什么时间完成任务。</code></p>\n<p>而且在复杂一点的情况下，比如多个异步任务的场景，一个异步任务依赖上一个异步任务的执行结果，异步任务合并等，Future无法满足需求。</p>\n<h1 id=\"ListenableFuture\"><a href=\"#ListenableFuture\" class=\"headerlink\" title=\"ListenableFuture\"></a>ListenableFuture</h1><p>Google并发包下的listenableFuture对Java原生的future做了扩展，顾名思义就是使用监听器模式实现的回调，所以叫可监听的future。</p>\n<p>要使用listenableFuture还要结合MoreExecutor线程池，MoreExecutor是对Java原生线程池的封装，比如常用的MoreExecutors.listeningDecorator(threadPool); 修改Java原生线程池的submit方法，封装了future返回listenableFuture。<br>接口信息如下图所示：<br><img src=\"https://s3.bmp.ovh/imgs/2023/05/31/38d7ecdc6230f9e8.png\"><br>代码示例如下：<br>首先还是创建线程池,模拟业务调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//创建线程池  </span><br><span class=\"hljs-type\">ListeningExecutorService</span> <span class=\"hljs-variable\">executor</span> <span class=\"hljs-operator\">=</span> MoreExecutors.listeningDecorator(Executors.newCachedThreadPool());  <br><span class=\"hljs-comment\">// 模拟接口调用  </span><br>ListenableFuture&lt;String&gt; future = executor.submit(() -&gt; &#123;  <br>    Thread.sleep(<span class=\"hljs-number\">2</span>*<span class=\"hljs-number\">1000</span>);  <br>    <span class=\"hljs-comment\">// int i = 1 / 0;  </span><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;hello world&quot;</span>;  <br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>上面的代码是构造了一个ListenableFuture的异步任务，调用它的结果一般有两种方式：</p>\n<ul>\n<li>基于监听器(addListener)<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 基于监听机制  </span><br>future.addListener(() -&gt; &#123;  <br>    <span class=\"hljs-keyword\">try</span> &#123;  <br>        System.out.println(<span class=\"hljs-string\">&quot;异步结果:&quot;</span> + future.get());  <br>    &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;  <br>        e.printStackTrace();  <br>    &#125;  <br>&#125;, executor);<br></code></pre></td></tr></table></figure></li>\n<li>基于回调（addCallback）<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">// 基于回调机制  </span><br>Futures.addCallback(future, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FutureCallback</span>&lt;String&gt;() &#123;  <br>    <span class=\"hljs-meta\">@Override</span>  <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onSuccess</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@Nullable</span> String result)</span> &#123;  <br>        System.out.println(<span class=\"hljs-string\">&quot;异步结果:&quot;</span> + result);  <br>    &#125;  <br>    <span class=\"hljs-meta\">@Override</span>  <br>    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">onFailure</span><span class=\"hljs-params\">(Throwable t)</span> &#123;  <br>        System.out.println(<span class=\"hljs-string\">&quot;异步结果错误:&quot;</span> + t.getMessage());  <br>    &#125;  <br>&#125;);<br></code></pre></td></tr></table></figure>\n上述代码用例可以发现我注释掉了一个<code>int i = 1 / 0</code>,在学习过程中可以放开来看看结果，对比验证一下。<br>OK，上述如果验证完毕后，可以比对看下面的汇总，加深一下使用区别。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>使用说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>addListener</td>\n<td>需要自己代码里捕获处理异常情况，最好设置超时时间</td>\n</tr>\n<tr>\n<td>addCallback</td>\n<td>把正常返回和异常情况做了分离，方便我们针对不同情况做处理</td>\n</tr>\n</tbody></table>\n<p>另外Futures里还有很多其他的api，可以满足我们负责场景，比如transform()可以处理异步任务之间的依赖情况，allAsList()将多个ListenableFuture合并成一个。</p>\n<h1 id=\"CompletableFuture\"><a href=\"#CompletableFuture\" class=\"headerlink\" title=\"CompletableFuture\"></a>CompletableFuture</h1><p>如果你们公司的jdk是8或以上的版本，那可以直接使用CompletableFuture类来实现异步编程。</p>\n<p>Java8新增的CompletableFuture类借鉴了Google Guava的ListenableFuture，它包含50多个方法，默认使用forkJoinPool线程池，提供了非常强大的Future扩展功能，可以帮助我们简化异步编程的复杂性，结合函数式编程，通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的多种方法，可以满足大部分异步回调场景。<br>接口信息如下图所示：<br><img src=\"https://s3.bmp.ovh/imgs/2023/06/01/6aac59f5cb214601.png\"></p>\n<p>虽然方法很多但有个特征：</p>\n<ul>\n<li>以Async结尾的方法签名表示是在异步线程里执行，没有以Async结尾的方法则是由主线程调用</li>\n<li>如果参数里有Runnable类型，则没有返回结果，即纯消费的方法  </li>\n<li>如果参数里没有指定executor则默认使用forkJoinPool线程池，指定了则以指定的线程池来执行任务</li>\n</ul>\n<h2 id=\"thenApplyAsync\"><a href=\"#thenApplyAsync\" class=\"headerlink\" title=\"thenApplyAsync\"></a>thenApplyAsync</h2><h3 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h3><blockquote>\n<p>&#x3D;&#x3D;这里先说明一下，示例代码只关注核心功能，如果要实际使用需要考虑超时和异常情况，大家需要注意。&#x3D;&#x3D;</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">CompletableFuture&lt;String&gt; f1 = CompletableFuture  <br>        .supplyAsync(() -&gt; &#123;  <br>            System.out.println(<span class=\"hljs-string\">&quot;...开始执行hello&quot;</span>);  <br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">hello</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;hello! &quot;</span>;  <br>            <span class=\"hljs-comment\">//int i = 1/0;  </span><br>            System.out.println(<span class=\"hljs-string\">&quot;...执行hello完毕，执行结果：&quot;</span> + hello);  <br>            <span class=\"hljs-keyword\">return</span> hello;  <br>        &#125;).thenApplyAsync(s -&gt; &#123;  <br>            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">world</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;world!&quot;</span>;  <br>            System.out.println(<span class=\"hljs-string\">&quot;...获取上一步结果,结果为：&quot;</span> + s);  <br>            System.out.println(<span class=\"hljs-string\">&quot;开始输出 &quot;</span> + world);  <br>            <span class=\"hljs-keyword\">return</span> s + world;  <br>        &#125;);  <br>System.out.println(<span class=\"hljs-string\">&quot;f1.get() = &quot;</span> + f1.get());<br></code></pre></td></tr></table></figure>",
            "tags": [
                "JAVA",
                "异步编程",
                "线程"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/30/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/JAVA/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B(1)-%E5%88%9D%E8%AF%86%E5%BC%82%E6%AD%A5/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/30/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/JAVA/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B(1)-%E5%88%9D%E8%AF%86%E5%BC%82%E6%AD%A5/",
            "title": "异步编程(1)-初识异步",
            "date_published": "2023-05-30T03:38:55.141Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>近期博猪在负责一个风险测算的模块，其中的具体过程博猪就不细说了，但是总体的感觉就是心中有无数个草泥马在奔腾，但是现在仔细感觉还是值得写个博客来记录一下的。<br>具体场景为有些业务导入牵扯到一些计算，业务那边说是导入数据量比较庞大，所以博猪就用异步+多线程的方式处理了这个业务，本地和Linux环境跑了几遍，20个字段，2w数据，5个线程，总体耗时也就三秒左右，还是挺可观的。</p>\n</blockquote>\n<h1 id=\"什么异步编程\"><a href=\"#什么异步编程\" class=\"headerlink\" title=\"什么异步编程\"></a>什么异步编程</h1><p>Java 异步编程是一种让程序并行运行的方式，它可以让程序中的一个工作单元与主应用程序线程分开独立运行，并且等工作单元运行结束后通知主应用程序线程它的运行结果或者失败原因。使用异步编程有许多好处，例如可以提高应用程序的性能和响应能力，提高线程的利用率，减少线程间的通信开销等。<br>Java 异步编程的核心是线程池，程序员可以通过提交任务到线程池来实现异步编程。<br>Java 异步编程在现实生活中有很多应用，例如网络 IO 请求、日志打印、异步打日志、异步消息处理等。<br>具体来说,Java异步编程包括以下几个要点:</p>\n<ul>\n<li>启动异步任务:通过某种机制启动一个与主程序分离的异步任务,比如线程、Future、CompletableFuture等。</li>\n<li>异步任务独立执行:一旦异步任务启动,主程序可以继续执行,而异步任务将在后台独立运行。</li>\n<li>获取异步执行的结果(可选):主程序如果需要异步任务的结果,可以通过某种方式获取其结果,比如调用Future的get方法或给CompletionHandler传递结果。但这不是异步执行的必要条件,有的异步任务不需要返回结果。</li>\n<li>异常处理(可选):通过 completion handlers 或其他异常处理机制对异步任务可能抛出的异常进行处理。</li>\n<li>线程管理(可选):有的异步方式需要手动管理执行线程,有的则通过线程池等机制自动管理。<br>所以,总体来说,Java异步编程的关键就是启动一个与主程序分离的异步任务,并让其在后台运行,而主程序可以继续流程,不等待其完成。在需要结果或异常时,再通过相应机制获取或处理。<br>这一模式允许程序同时处理多个任务,提高了程序的并发能力和响应性。线程的自动管理也简化了手动管理线程的难度。Java提供了多种实现异步编程的方式,比如线程、Future、CompletableFuture、响应式框架等。随着Java的发展,这些方式越来越简便高效。<br>但其核心思想仍然是让异步任务独立于主程序执行,以实现并发和提高响应性。</li>\n</ul>\n",
            "tags": [
                "思考",
                "JAVA",
                "异步编程",
                "线程"
            ]
        }
    ]
}