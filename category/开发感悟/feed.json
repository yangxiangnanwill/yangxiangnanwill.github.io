{
    "version": "https://jsonfeed.org/version/1",
    "title": "Will • All posts by \"开发感悟\" category",
    "description": "愿你一生努力，一生被爱",
    "home_page_url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io",
    "items": [
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2026/01/04/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/%E5%BC%80%E5%8F%91%E6%84%9F%E6%82%9F/%E4%B8%9A%E5%8A%A1%E5%B8%B8%E8%A7%81%E5%BC%80%E5%8F%91%E9%94%99%E8%AF%AF(1)-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2026/01/04/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/%E5%BC%80%E5%8F%91%E6%84%9F%E6%82%9F/%E4%B8%9A%E5%8A%A1%E5%B8%B8%E8%A7%81%E5%BC%80%E5%8F%91%E9%94%99%E8%AF%AF(1)-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%BA%93/",
            "title": "业务常见开发错误(1)-并发工具类库",
            "date_published": "2026-01-04T02:06:38.347Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>曾经的我一度以为只要使用了并发工具类库就可以高枕无忧了，万世大吉了，或者说使用一些并发工具类库总是写出一些是是而非，总是驴唇不对马嘴的代码来，最后的结果只是徒增烦恼。<br>举个简单鹅栗子，就是面试题中经常出现的:<code>HashMap</code>和<code>ConcurrentHashMap</code>以及<code>CopyOnWriteArrayList</code>的区别即用途，以及性能，但是通过各种云里雾绕的解释之后，只是浅显的只是让大脑知道这几个性能要更好，所以下次你只会下意思的使用这几个类库，但是事实上真的如此么？其实并不尽然。</p>\n<p>的确，为了方便开发者进行多线程编程，现代编程语言会提供各种并发工具类。但如果我们没有充分了解它们的使用场景、解决的问题，以及最佳实践的话，盲目使用就可能会导致一些坑，小则损失性能，大则无法确保多线程情况下业务逻辑的正确性。</p>\n<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><h2 id=\"线程重用\"><a href=\"#线程重用\" class=\"headerlink\" title=\"线程重用\"></a>线程重用</h2><p>案例：<br>没有意识到线程重用导致用户信息错乱的 Bug。<br>之前遇到一个诡异的问题，用户每次登录后获取的信息不一致，有时获取到的用户信息是别人的。查看代码后，当然为了所谓的性能考虑这里使用了 ThreadLocal 来缓存获取到的用户信息。当然你也会看到各种框架都在使用这个的牛x的工具类，所以我就百度了一下然后直接使用了这个工具类。</p>\n<p>我们知道，ThreadLocal 适用于变量在线程间隔离，而在方法或类间共享的场景。如果用户信息的获取比较昂贵（比如从数据库查询用户信息），那么在 ThreadLocal 中缓存数据是比较合适的做法。但，这么做为什么会出现用户信息错乱的 Bug 呢？</p>\n<p>案例复现：</p>\n<ul>\n<li>使用 Spring Boot 创建一个 Web 应用程序，使用 ThreadLocal 存放一个 Integer 的值，来暂且代表需要在线程中保存的用户信息，这个值初始是 null。</li>\n<li>在业务逻辑中，我先从 ThreadLocal 获取一次值，然后把外部传入的参数设置到 ThreadLocal 中，来模拟从当前上下文获取到用户信息的逻辑，随后再获取一次值，最后输出两次获得的值和线程名称。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> ThreadLocal&lt;Integer&gt; currentUser = ThreadLocal.withInitial(() -&gt; <span class=\"hljs-literal\">null</span>);  <br>  <br><span class=\"hljs-meta\">@GetMapping(&quot;/wrong&quot;)</span>  <br><span class=\"hljs-keyword\">public</span> Map <span class=\"hljs-title function_\">wrong</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@RequestParam(&quot;userId&quot;)</span> Integer userId)</span> &#123;  <br>    <span class=\"hljs-comment\">// 设置用户信息之前先查询一次ThreadLocal的用户信息  </span><br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">before</span> <span class=\"hljs-operator\">=</span> Thread.currentThread().getName() + <span class=\"hljs-string\">&quot;:&quot;</span> + currentUser.get();  <br>    <span class=\"hljs-comment\">// 设置用户信息到ThreadLocal  </span><br>    currentUser.set(userId);  <br>    <span class=\"hljs-comment\">// 设置用户信息之后再查询一次ThreadLocal的用户信息  </span><br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">after</span> <span class=\"hljs-operator\">=</span> Thread.currentThread().getName() + <span class=\"hljs-string\">&quot;:&quot;</span> + currentUser.get();  <br>    <span class=\"hljs-comment\">// 汇总输出两次查询结果  </span><br>    <span class=\"hljs-type\">Map</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>();  <br>    result.put(<span class=\"hljs-string\">&quot;before&quot;</span>, before);  <br>    result.put(<span class=\"hljs-string\">&quot;after&quot;</span>, after);  <br>    <span class=\"hljs-keyword\">return</span> result;  <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>按理说，在设置用户信息之前第一次获取的值始终应该是 null，但我们要意识到，程序运行在 Tomcat 中，执行程序的线程是 Tomcat 的工作线程，而 Tomcat 的工作线程是基于线程池的。</p>\n<p>顾名思义，线程池会重用固定的几个线程，一旦线程重用，那么很可能首次从 ThreadLocal 获取的值是之前其他用户的请求遗留的值。这时，ThreadLocal 中的用户信息就是其他用户的信息。</p>\n<p>为了更快地重现这个问题，我在配置文件中设置一下 Tomcat 的参数，把工作线程池最大线程数设置为 1，这样始终是同一个线程在处理请求：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs properties\"><span class=\"hljs-attr\">server.tomcat.max-threads</span>=<span class=\"hljs-string\">1</span><br></code></pre></td></tr></table></figure>\n<p>运行程序后先让用户 1 来请求接口，可以看到第一和第二次获取到用户 ID 分别是 null 和 1，符合预期;<br>随后用户 2 来请求接口，这次就出现了 Bug，第一和第二次获取到用户 ID 分别是 1 和 2，显然第一次获取到了用户 1 的信息，我们查看idea中的日志，发现线程名称都为<code>http-nio-8080-exec-1</code>,所以我们就能知道因为线程池重用线程导致我们上诉的问题。</p>\n<p>虽然平时可能会抱怨学多线程没用，因为代码里没有开启使用多线程。但其实，可能只是我们没有意识到，在 Tomcat 这种 Web 服务器下跑的业务代码，本来就运行在一个多线程环境（否则接口也不可能支持这么高的并发），<strong>并不能认为没有显式开启多线程就不会有线程安全问题。</strong></p>\n<p>因为线程的创建比较昂贵，所以 Web 服务器往往会使用线程池来处理请求，这就意味着线程会被重用。这时，<strong>使用类似 ThreadLocal 工具来存放一些数据时，需要特别注意在代码运行完后，显式地去清空设置的数据。</strong> 如果在代码中使用了自定义的线程池，也同样会遇到这个问题。</p>\n<p>理解了这个知识点后，在代码的 finally 代码块中，显式清除 ThreadLocal 中的数据。这样一来，新的请求过来即使使用了之前的线程也不会获取到错误的用户信息了。修正后的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@GetMapping(&quot;/right&quot;)</span>  <br><span class=\"hljs-keyword\">public</span> Map <span class=\"hljs-title function_\">right</span><span class=\"hljs-params\">(<span class=\"hljs-meta\">@RequestParam(&quot;userId&quot;)</span> Integer userId)</span> &#123;  <br>    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">before</span> <span class=\"hljs-operator\">=</span> Thread.currentThread().getName() + <span class=\"hljs-string\">&quot;:&quot;</span> + currentUser.get();  <br>    currentUser.set(userId);  <br>    <span class=\"hljs-keyword\">try</span> &#123;  <br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">after</span> <span class=\"hljs-operator\">=</span> Thread.currentThread().getName() + <span class=\"hljs-string\">&quot;:&quot;</span> + currentUser.get();  <br>        <span class=\"hljs-type\">Map</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>();  <br>        result.put(<span class=\"hljs-string\">&quot;before&quot;</span>, before);  <br>        result.put(<span class=\"hljs-string\">&quot;after&quot;</span>, after);  <br>        <span class=\"hljs-keyword\">return</span> result;  <br>    &#125;<span class=\"hljs-keyword\">finally</span> &#123;  <br>        <span class=\"hljs-comment\">//在finally代码块中删除ThreadLocal中的数据，确保数据不串  </span><br>        currentUser.remove();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>重新运行程序可以验证，再也不会出现第一次查询用户信息查询到之前用户请求的 Bug。</p>\n<p>ThreadLocal 是利用独占资源的方式，来解决线程安全问题，那如果我们确实需要有资源在线程之前共享，应该怎么办呢？这时，我们可能就需要用到线程安全的容器了。</p>\n<h2 id=\"并发工具\"><a href=\"#并发工具\" class=\"headerlink\" title=\"并发工具\"></a>并发工具</h2><p>使用了线程安全的并发工具，并不代表解决了所有线程安全问题。<br>JDK 1.5 后推出的 ConcurrentHashMap，是一个高性能的线程安全的哈希表容器。“线程安全”这四个字特别容易让人误解，因为 ConcurrentHashMap 只能保证提供的原子性读写操作是线程安全的。</p>\n<p>比如下面这个场景。有一个含 900 个元素的 Map，现在再补充 100 个元素进去，这个补充操作由 10 个线程并发进行。</p>\n<p>开发人员误以为使用了 ConcurrentHashMap 就不会有线程安全问题，于是不加思索地写出了下面的代码：在每一个线程的代码逻辑中先通过 size 方法拿到当前元素数量，计算 ConcurrentHashMap 目前还需要补充多少元素，并在日志中输出了这个值，然后通过 putAll 方法把缺少的元素添加进去。</p>\n<p>为方便观察问题，我们输出了这个 Map 一开始和最后的元素个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//线程个数  </span><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">THREAD_COUNT</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;  <br><span class=\"hljs-comment\">// 总元素数量  </span><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ITEM_COUNT</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1000</span>;  <br>  <br><span class=\"hljs-comment\">//模拟生成数据  </span><br><span class=\"hljs-keyword\">private</span> ConcurrentHashMap&lt;String, Long&gt; <span class=\"hljs-title function_\">getData</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> count)</span> &#123;  <br>    <span class=\"hljs-keyword\">return</span> LongStream.rangeClosed(<span class=\"hljs-number\">1</span>, count)  <br>            .boxed()  <br>            .collect(Collectors.toConcurrentMap(i -&gt; UUID.randomUUID().toString(), Function.identity(),  <br>                    ((o1, o2) -&gt; o1), ConcurrentHashMap::<span class=\"hljs-keyword\">new</span>));  <br>&#125;<br><span class=\"hljs-meta\">@GetMapping(&quot;wrong&quot;)</span>  <br><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">wrong</span><span class=\"hljs-params\">()</span> &#123;  <br>    <span class=\"hljs-comment\">// 初始化900个元素  </span><br>    ConcurrentHashMap&lt;String, Long&gt; concurrentHashMap = getData(ITEM_COUNT - <span class=\"hljs-number\">100</span>);  <br>    log.info(<span class=\"hljs-string\">&quot;init size：&#123;&#125;&quot;</span>, concurrentHashMap.size());  <br>    <span class=\"hljs-type\">ForkJoinPool</span> <span class=\"hljs-variable\">forkJoinPool</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ForkJoinPool</span>(THREAD_COUNT);  <br>    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10</span>).parallel().forEach(i -&gt; &#123;  <br>        <span class=\"hljs-comment\">// 查询还需要填充多少个元素  </span><br>        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">gap</span> <span class=\"hljs-operator\">=</span> ITEM_COUNT - concurrentHashMap.size();  <br>        log.info(<span class=\"hljs-string\">&quot;gap size:&#123;&#125;&quot;</span>, gap);  <br>        <span class=\"hljs-comment\">// 补充元素  </span><br>        concurrentHashMap.putAll(getData(gap));  <br>    &#125;));  <br>    <span class=\"hljs-comment\">// 等待所有任务完成  </span><br>    forkJoinPool.shutdown();  <br>    forkJoinPool.awaitQuiescence(<span class=\"hljs-number\">1</span>, TimeUnit.HOURS);  <br>    <span class=\"hljs-comment\">// 最后元素个数  </span><br>    log.info(<span class=\"hljs-string\">&quot;finish size:&#123;&#125;&quot;</span>, concurrentHashMap.size());  <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;OK&quot;</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从日志中可以看到：</p>\n<ul>\n<li>初始大小 900 符合预期，还需要填充 100 个元素。</li>\n<li>worker1 线程查询到当前需要填充的元素为 36，竟然还不是 100 的倍数。</li>\n<li>worker13 线程查询到需要填充的元素数是负的，显然已经过度填充了。</li>\n</ul>\n<p>最后 HashMap 的总项目数是 1536，显然不符合填充满 1000 的预期。</p>\n<p>针对这个场景，我们可以举一个形象的例子。ConcurrentHashMap 就像是一个大篮子，现在这个篮子里有 900 个桔子，我们期望把这个篮子装满 1000 个桔子，也就是再装 100 个桔子。有 10 个工人来干这件事儿，大家先后到岗后会计算还需要补多少个桔子进去，最后把桔子装入篮子。</p>\n<p>ConcurrentHashMap 这个篮子本身，可以确保多个工人在装东西进去时，不会相互影响干扰，但无法确保工人 A 看到还需要装 100 个桔子但是还未装的时候，工人 B 就看不到篮子中的桔子数量。更值得注意的是，你往这个篮子装 100 个桔子的操作不是原子性的，在别人看来可能会有一个瞬间篮子里有 964 个桔子，还需要补 36 个桔子。</p>\n<p>回到 ConcurrentHashMap，我们需要注意 ConcurrentHashMap 对外提供的方法或能力的限制：<br>使用了 ConcurrentHashMap，不代表对它的多个操作之间的状态是一致的，是没有其他线程在操作它的，如果需要确保需要手动加锁。<br>诸如 size、isEmpty 和 containsValue 等聚合方法，在并发情况下可能会反映 ConcurrentHashMap 的中间状态。因此在并发情况下，这些方法的返回值只能用作参考，而不能用于流程控制。显然，利用 size 方法计算差异值，是一个流程控制。<br>诸如 putAll 这样的聚合方法也不能确保原子性，在 putAll 的过程中去获取数据可能会获取到部分数据。<br>代码的修改方案很简单，整段逻辑加锁即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@GetMapping(&quot;/right&quot;)</span>  <br><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">right</span><span class=\"hljs-params\">()</span> &#123;  <br>    <span class=\"hljs-comment\">// 初始化900个元素  </span><br>    ConcurrentHashMap&lt;String, Long&gt; concurrentHashMap = getData(ITEM_COUNT - <span class=\"hljs-number\">100</span>);  <br>    log.info(<span class=\"hljs-string\">&quot;init size：&#123;&#125;&quot;</span>, concurrentHashMap.size());  <br>    <span class=\"hljs-type\">ForkJoinPool</span> <span class=\"hljs-variable\">forkJoinPool</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ForkJoinPool</span>(THREAD_COUNT);  <br>    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">10</span>).parallel().forEach(i -&gt; &#123;  <br>        <span class=\"hljs-keyword\">synchronized</span> (concurrentHashMap) &#123;  <br>            <span class=\"hljs-comment\">// 查询还需要填充多少个元素  </span><br>            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">gap</span> <span class=\"hljs-operator\">=</span> ITEM_COUNT - concurrentHashMap.size();  <br>            log.info(<span class=\"hljs-string\">&quot;gap size:&#123;&#125;&quot;</span>, gap);  <br>            <span class=\"hljs-comment\">// 补充元素  </span><br>            concurrentHashMap.putAll(getData(gap));  <br>        &#125;  <br>    &#125;));  <br>    <span class=\"hljs-comment\">// 等待所有任务完成  </span><br>    forkJoinPool.shutdown();  <br>    forkJoinPool.awaitQuiescence(<span class=\"hljs-number\">1</span>, TimeUnit.HOURS);  <br>    <span class=\"hljs-comment\">// 最后元素个数  </span><br>    log.info(<span class=\"hljs-string\">&quot;finish size:&#123;&#125;&quot;</span>, concurrentHashMap.size());  <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;OK&quot;</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>重新调用接口，程序的日志输出结果符合预期。</p>\n<p>可以看到，只有一个线程查询到了需要补 100 个元素，其他 9 个线程查询到不需要补元素，最后 Map 大小为 1000。<br>到了这里，你可能又要问了，使用 ConcurrentHashMap 全程加锁，还不如使用普通的 HashMap 呢。<br>其实不完全是这样。<br>ConcurrentHashMap 提供了一些原子性的简单复合逻辑方法，用好这些方法就可以发挥其威力。这就引申出代码中常见的另一个问题：在使用一些类库提供的高级工具类时，开发人员可能还是按照旧的方式去使用这些新类，因为没有使用其特性，所以无法发挥其威力。</p>\n<h2 id=\"并发工具特性\"><a href=\"#并发工具特性\" class=\"headerlink\" title=\"并发工具特性\"></a>并发工具特性</h2><p>没有充分了解并发工具的特性，从而无法发挥其威力</p>\n<p>我们来看一个使用 Map 来统计 Key 出现次数的场景吧，这个逻辑在业务代码中非常常见。<br>使用 ConcurrentHashMap 来统计，Key 的范围是 10。<br>使用最多 10 个并发，循环操作 1000 万次，每次操作累加随机的 Key。<br>如果 Key 不存在的话，首次设置值为 1。<br>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//线程个数  </span><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">THREAD_COUNT</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;  <br><span class=\"hljs-comment\">// 总元素数量  </span><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">ITEM_COUNT</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1000</span>;  <br><span class=\"hljs-comment\">// 循环次数  </span><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">LOOP_COUNT</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10000000</span>;<br><br><span class=\"hljs-keyword\">private</span> Map&lt;String, Long&gt; <span class=\"hljs-title function_\">normalUse</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException &#123;  <br>    ConcurrentHashMap&lt;String, Long&gt; freqs = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentHashMap</span>&lt;&gt;(ITEM_COUNT);  <br>    <span class=\"hljs-type\">ForkJoinPool</span> <span class=\"hljs-variable\">forkJoinPool</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ForkJoinPool</span>(THREAD_COUNT);  <br>    forkJoinPool.execute(()-&gt; IntStream.rangeClosed(<span class=\"hljs-number\">1</span>,LOOP_COUNT).parallel().forEach(i-&gt;&#123;  <br>        <span class=\"hljs-comment\">// 随机获取key  </span><br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">key</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;item&quot;</span> + ThreadLocalRandom.current().nextInt(ITEM_COUNT);  <br>        <span class=\"hljs-keyword\">synchronized</span> (freqs) &#123;  <br>            <span class=\"hljs-comment\">// 如果key存在则+1  </span><br>            <span class=\"hljs-keyword\">if</span> (freqs.containsKey(key)) &#123;  <br>                freqs.put(key, freqs.get(key) + <span class=\"hljs-number\">1</span>);  <br>            &#125;  <br>            <span class=\"hljs-comment\">// 如果可以不存在则初始化为1  </span><br>            <span class=\"hljs-keyword\">else</span> &#123;  <br>                freqs.put(key, <span class=\"hljs-number\">1L</span>);  <br>            &#125;  <br>        &#125;  <br>    &#125;));  <br>    forkJoinPool.shutdown();  <br>    forkJoinPool.awaitTermination(<span class=\"hljs-number\">1</span>, TimeUnit.HOURS);  <br>    <span class=\"hljs-keyword\">return</span> freqs;  <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们吸取之前的教训，直接通过锁的方式锁住 Map，然后做判断、读取现在的累计值、加 1、保存累加后值的逻辑。这段代码在功能上没有问题，但无法充分发挥 ConcurrentHashMap 的威力，改进后的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> Map&lt;String, Long&gt; <span class=\"hljs-title function_\">goodUse</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException &#123;  <br>    ConcurrentHashMap&lt;String, LongAdder&gt; freqs = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConcurrentHashMap</span>&lt;&gt;(ITEM_COUNT);  <br>    <span class=\"hljs-type\">ForkJoinPool</span> <span class=\"hljs-variable\">forkJoinPool</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ForkJoinPool</span>(THREAD_COUNT);  <br>    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(<span class=\"hljs-number\">1</span>, LOOP_COUNT).parallel().forEach(i-&gt;&#123;  <br>        <span class=\"hljs-comment\">// 随机获取key  </span><br>        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">key</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;item&quot;</span> + ThreadLocalRandom.current().nextInt(ITEM_COUNT);  <br>        <span class=\"hljs-comment\">//利用computeIfAbsent()方法来实例化LongAdder，然后利用LongAdder来进行线程安全计数  </span><br>        freqs.computeIfAbsent(key, k -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LongAdder</span>()).increment();  <br>  <br>    &#125;));  <br>    forkJoinPool.shutdown();  <br>    forkJoinPool.awaitTermination(<span class=\"hljs-number\">1</span>, TimeUnit.HOURS);  <br>    <span class=\"hljs-comment\">//因为我们的Value是LongAdder而不是Long，所以需要做一次转换才能返回  </span><br>    <span class=\"hljs-keyword\">return</span> freqs.entrySet().stream()  <br>            .collect(Collectors.toMap(e -&gt; e.getKey(), e -&gt; e.getValue().longValue()));  <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在这段改进后的代码中，我们巧妙利用了下面两点：<br>使用 ConcurrentHashMap 的原子性方法 computeIfAbsent 来做复合逻辑操作，判断 Key 是否存在 Value，如果不存在则把 Lambda 表达式运行后的结果放入 Map 作为 Value，也就是新创建一个 LongAdder 对象，最后返回 Value。<br>由于 computeIfAbsent 方法返回的 Value 是 LongAdder，是一个线程安全的累加器，因此可以直接调用其 increment 方法进行累加。<br>这样在确保线程安全的情况下达到极致性能，把之前 7 行代码替换为了 1 行。<br>我们通过一个简单的测试比较一下修改前后两段代码的性能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@GetMapping(&quot;good&quot;)</span>  <br><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">good</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException &#123;  <br>    <span class=\"hljs-type\">StopWatch</span> <span class=\"hljs-variable\">stopWatch</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">StopWatch</span>();  <br>    stopWatch.start(<span class=\"hljs-string\">&quot;normalUse&quot;</span>);  <br>    Map&lt;String, Long&gt; normalUse = normalUse();  <br>    stopWatch.stop();  <br>    <span class=\"hljs-comment\">// 校验元素数量  </span><br>    Assert.isTrue(normalUse.size() == ITEM_COUNT, <span class=\"hljs-string\">&quot;normalUse size error&quot;</span>);  <br>    <span class=\"hljs-comment\">// 校验累计总数  </span><br>    Assert.isTrue(normalUse  <br>            .entrySet()  <br>            .stream()  <br>            .mapToLong(item -&gt; item.getValue())  <br>            .reduce(<span class=\"hljs-number\">0</span>, Long::sum) == LOOP_COUNT, <span class=\"hljs-string\">&quot;normalUse count error&quot;</span>);  <br>    stopWatch.start(<span class=\"hljs-string\">&quot;goodUse&quot;</span>);  <br>    Map&lt;String, Long&gt; goodUse = goodUse();  <br>    stopWatch.stop();  <br>    <span class=\"hljs-comment\">// 校验元素数量  </span><br>    Assert.isTrue(goodUse.size() == ITEM_COUNT, <span class=\"hljs-string\">&quot;goodUse size error&quot;</span>);  <br>    <span class=\"hljs-comment\">// 校验累计总数  </span><br>    Assert.isTrue(goodUse  <br>            .entrySet()  <br>            .stream()  <br>            .mapToLong(item -&gt; item.getValue())  <br>            .reduce(<span class=\"hljs-number\">0</span>, Long::sum) == LOOP_COUNT, <span class=\"hljs-string\">&quot;goodUse count error&quot;</span>);  <br>    log.info(stopWatch.prettyPrint());  <br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;OK&quot;</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这段测试代码并无特殊之处，使用 StopWatch 来测试两段代码的性能，最后跟了一个断言判断 Map 中元素的个数以及所有 Value 的和，是否符合预期来校验代码的正确性。测试结果如下：</p>\n<p>可以看到，优化后的代码，相比使用锁来操作 ConcurrentHashMap 的方式，性能提升了 10 倍。</p>\n<p>你可能会问，computeIfAbsent 为什么如此高效呢？</p>\n<p>答案就在源码最核心的部分，也就是 Java 自带的 Unsafe 实现的 CAS。它在虚拟机层面确保了写入数据的原子性，比加锁的效率高得多：</p>\n",
            "tags": [
                "开发习惯",
                "开发错误"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/25/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/%E5%BC%80%E5%8F%91%E6%84%9F%E6%82%9F/%E5%BC%80%E5%8F%91%E5%A5%BD%E4%B9%A0%E6%83%AF/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/25/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/%E5%BC%80%E5%8F%91%E6%84%9F%E6%82%9F/%E5%BC%80%E5%8F%91%E5%A5%BD%E4%B9%A0%E6%83%AF/",
            "title": "开发好习惯",
            "date_published": "2023-05-25T06:03:25.912Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>写干净的代码，做风一样的男子！</p>\n</blockquote>\n<p>编程5分钟，查代码2小时!</p>\n<p>在程序员的编程生涯，免不了和BUG打交道，甚至有些程序员被BUG虐杀的苦不堪言。</p>\n<p><img src=\"https://p3-tt.byteimg.com/origin/4ada0003ada15e3b0683?from=pc\" alt=\"程序员减少代码BUG的7种方法，写干净的代码，做风一样的男子！\"></p>\n<p><strong>当有人指出程序员代码有BUG时，程序员的回答各有不同：</strong></p>\n<ul>\n<li>不可能啊，在我电脑上运行没有问题呀!</li>\n<li>我已经一星期没碰这块代码啦!</li>\n<li>没事，我改一行代码就可以了，不影响程序。</li>\n</ul>\n<div>\n<center>程序员调 Bug 的样子，非常真实~</center>\n</div>\n\n<p>​                                                                                                                         <center>↓↓↓</center></p>\n<p><img src=\"https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_gif/2A8tXicCG8yka2rcVsmkqPjN4taJfwp3wUy7KTTM4IhnOjTMdC3zXRYGElM7Pia1AhvV02UlibtPKoRFc9icv40dHA/0?wx_fmt=gif&wxfrom=5&wx_lazy=1\" alt=\"0?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1\"></p>\n<p><img src=\"https://ss.csdn.net/p?http://mmbiz.qpic.cn/mmbiz_gif/2A8tXicCG8yka2rcVsmkqPjN4taJfwp3wxQKXe3ibNiadib0xqp2uYXribWiby2WCrXmO4q1CXAibbpugibUNvdA2yuuNQ/0?wx_fmt=gif&wxfrom=5&wx_lazy=1\" alt=\"0?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1\"></p>\n<p><img src=\"https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_gif/2A8tXicCG8yka2rcVsmkqPjN4taJfwp3w5fLdGxLudXOB5pdrwh2vbClrZU7KC5QysFhibrkP9spDK2kONPHTUnw/0?wx_fmt=gif\" alt=\"0?wx_fmt=gif\"></p>\n<blockquote>\n<p>调bug是火，bug是烟。一处点火，四处冒烟</p>\n<p>下面奉上我日常开发的一些总结.</p>\n</blockquote>\n<h1 id=\"如何减少代码的BUG呢-在此分享几个技巧\"><a href=\"#如何减少代码的BUG呢-在此分享几个技巧\" class=\"headerlink\" title=\"如何减少代码的BUG呢?在此分享几个技巧\"></a>如何减少代码的BUG呢?在此分享几个技巧</h1><h2 id=\"别对警告视而不见\"><a href=\"#别对警告视而不见\" class=\"headerlink\" title=\"别对警告视而不见\"></a>别对警告视而不见</h2><p>相信不少的程序员会使用IDEA，使用它敲代码，有时候会出现警告，那么这时你对警告就不能视而不见了。</p>\n<p><strong>我们的目标是，写干净的代码，做风一样的男子!</strong></p>\n<p><img src=\"https://p1-tt.byteimg.com/origin/4add00036e54d5cefc42?from=pc\" alt=\"程序员减少代码BUG的7种方法，写干净的代码，做风一样的男子！\"></p>\n<h2 id=\"编程习惯\"><a href=\"#编程习惯\" class=\"headerlink\" title=\"编程习惯\"></a>编程习惯</h2><p>种瓜得瓜种豆得豆，好的编程习惯可以大大降低BUG数量。譬如有if必须写else，即使else是个空语句 。</p>\n<h2 id=\"写代码的时间问题\"><a href=\"#写代码的时间问题\" class=\"headerlink\" title=\"写代码的时间问题\"></a>写代码的时间问题</h2><p>对于程序员而言，千万别熬夜写代码。一些程序员在晚上11点，仍然在敲代码。</p>\n<p>虽然你自己觉得头脑其实很清醒，但是第二天自测，或者QA测试的时候你有可能就会发现问题很多。</p>\n<p><strong>我们一般不提倡长期加班写代码，因为那样会导致Bug率直线上升。</strong></p>\n<p><img src=\"https://p1-tt.byteimg.com/origin/4ade00036510b0efbb55?from=pc\" alt=\"程序员减少代码BUG的7种方法，写干净的代码，做风一样的男子！\"></p>\n<h2 id=\"验证、自测\"><a href=\"#验证、自测\" class=\"headerlink\" title=\"验证、自测\"></a>验证、自测</h2><p>在提交测试前要多验证，其中包括自动化测试、手动跑用例等。</p>\n<p>有一句话说的好，千万别怕麻烦，不然你会麻烦一辈子。</p>\n<p>这也是我认为我现在坚持的比较好的一点，自测ok，然后交给业务测试</p>\n<h2 id=\"仔细的DEBUG\"><a href=\"#仔细的DEBUG\" class=\"headerlink\" title=\"仔细的DEBUG\"></a>仔细的DEBUG</h2><p>在2.4基础上建议自测是仔细的DEBUG一遍，这样能对自己的代码心里有个范围，大体知道风险点和错误是便于直接调整自己的代码。</p>\n<h2 id=\"仔细的设计\"><a href=\"#仔细的设计\" class=\"headerlink\" title=\"仔细的设计\"></a>仔细的设计</h2><p>在程序员编写代码之前，必须对代码的整个结构以及逻辑结构胸有成竹。</p>\n<h2 id=\"避免干扰\"><a href=\"#避免干扰\" class=\"headerlink\" title=\"避免干扰\"></a>避免干扰</h2><p>有部分的程序员敲代码的时候，经常会一边听音乐一边敲代码，这样效率不仅仅低，而且也更容易产生BUG。</p>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>写注释，写注释，写注释。重要的事情说三遍。</p>\n<p>因为前期的注释有利于后续开发的时候容易减少bug。</p>\n<p><strong>自从修改了注释模板，整个人精神多了，bug也明显少了，如图：</strong></p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201215145135.png\" alt=\"image-20201215145125620\"></p>\n<h2 id=\"敢于维护上古代码\"><a href=\"#敢于维护上古代码\" class=\"headerlink\" title=\"敢于维护上古代码\"></a>敢于维护上古代码</h2><p>博猪开发时间其实很少，只有一年的时间，其实上古代码对于博猪的历练很大，俗话说的好多吃BUG,身体棒棒。博猪入职之后前半年一直维护一个SSI项目，里面用的技术很杂，有的在网上找不到，包括前端和后台，其次最重要的是业务方面，更是不懂，业务一般人不是给你讲的，所以我就一遍遍的启动本地DEBUG,慢慢啃下来的。</p>\n<p>‍</p>\n",
            "tags": [
                "开发习惯",
                "思考"
            ]
        }
    ]
}