{
    "version": "https://jsonfeed.org/version/1",
    "title": "Will • All posts by \"linux\" tag",
    "description": "愿你一生努力，一生被爱",
    "home_page_url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io",
    "items": [
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/09/18/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Linux/VMware/VMware-%E5%A4%8D%E5%88%B6%E8%99%9A%E6%8B%9F%E6%9C%BA&%E5%85%8B%E9%9A%86%E8%99%9A%E6%8B%9F%E6%9C%BA/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/09/18/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Linux/VMware/VMware-%E5%A4%8D%E5%88%B6%E8%99%9A%E6%8B%9F%E6%9C%BA&%E5%85%8B%E9%9A%86%E8%99%9A%E6%8B%9F%E6%9C%BA/",
            "title": "VMware-复制虚拟机&克隆虚拟机",
            "date_published": "2023-09-18T00:44:37.642Z",
            "content_html": "<blockquote>\n<p>关于虚拟机提示选择“我已移动该虚拟机”或“我已复制该虚拟机”</p>\n</blockquote>\n<ul>\n<li>我已移动该虚拟机<blockquote>\n<p>表示打开后，虚拟机的网卡的mac地址不变，如果复制的是本地的虚拟机，复制前的虚拟机和复制后的虚拟机同时开机会造成网络冲突。</p>\n</blockquote>\n</li>\n<li>我已复制该虚拟机<blockquote>\n<p>表示打开复制后的虚拟机的网卡的物理地址是新生成的，这样怎么开机都不会有网卡问题，所以VMware本身也是建议不知道的就选这个选项。</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"复制虚拟机\"><a href=\"#复制虚拟机\" class=\"headerlink\" title=\"复制虚拟机\"></a>复制虚拟机</h1><p>VMware 上创建的虚拟机是可以重复使用的，安装好的虚拟机可以直接复制或者剪切到其它任意电脑上，然后使用 VMware 打开使用，两者的虚拟机设置以及登录密码都完全一样。</p>\n<p>比如在某台电脑 A 上创建了 CentOS 7.2 的虚拟机（其它系统虚拟机如 windows、Red hat 也是同理），某一天在电脑 B 上也需要使用虚拟机，此时在电脑 B 上只需要安装 VMware 软件，然后从电脑 A 复制创建好的虚拟机文件目录到电脑 B，然后打开启动虚拟机即可。虚拟机的配置，如内存大小，处理器，磁盘大小等等，电脑 B 都会与电脑 A 中的保持一致，连登陆密码都是一致。</p>\n<p>这样的情况其实挺多的，比如从自己的旧电脑复制到新电脑上，或者从家里的笔记本复制到公司的台式机等等，如下动图所示，就是将旧电脑上创建好了的 CentOS 虚拟机整个目录复制到了新电脑上，然后运行 VMware 打开即可运行。</p>\n<p>注意：</p>\n<ul>\n<li>虽然虚拟机系统可以复制或者剪切重复使用，但是虚拟机系统内部安装的软件（比如 Java、mysql、docker等等）可能需要重新安装，造成原因如下：<ul>\n<li>新旧电脑的环境不一致</li>\n<li>因为旧电脑上使用的是 VMware 12，而新电脑使用的是 VMware 15</li>\n<li>直接复制的系统里面的程序本身真的需要重新安装。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"克隆虚拟机\"><a href=\"#克隆虚拟机\" class=\"headerlink\" title=\"克隆虚拟机\"></a>克隆虚拟机</h1><p>平时开发的时候需要做集群，比如 Redis 集群、Kafka 集群、微服务集群等等，为了更贴实际，就需要多台虚拟机，使用一个 VMware 开启多个 虚拟机系统，此时固然可以重新创建虚拟机、或者复制虚拟机，但是都没有克隆虚拟机来的快。</p>\n<p>克隆虚拟机只需简单几步，就能克隆一个一模一样的系统，虚拟机配置、登陆账户及密码等等完全一样、更重要的是连原系统安装的程序在新克隆的系统中都能继续使用。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p><font color=\"#c00000\">无法为已经开启或者挂起的虚拟机克隆，所以克隆前需要关闭虚拟机。</font></p>\n<h2 id=\"克隆步骤\"><a href=\"#克隆步骤\" class=\"headerlink\" title=\"克隆步骤\"></a>克隆步骤</h2><p>右键要克隆的虚拟机、选择管理 ——&gt; 克隆，进入克隆虚拟机向导，然后根据向导即可轻松创建。</p>\n<ul>\n<li>克隆源<ul>\n<li>虚拟机中的当前状态</li>\n<li>现有快照(仅限关闭的虚拟机)</li>\n</ul>\n</li>\n<li>克隆类型<ul>\n<li>创建链接克隆</li>\n<li>创建完整克隆</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"克隆后修改事项\"><a href=\"#克隆后修改事项\" class=\"headerlink\" title=\"克隆后修改事项\"></a>克隆后修改事项</h2><p>克隆后并不是直接能用，而是需要进行一些调试。 因为刚刚克隆完之后，克隆机和母机MAC地址一样，我们需要重新配置和删除网卡信息</p>\n<h3 id=\"修改MAC地址\"><a href=\"#修改MAC地址\" class=\"headerlink\" title=\"修改MAC地址\"></a>修改MAC地址</h3><p>通过虚拟机设置进行修改，点击生成即可<br>虚拟机设置-&gt;网络适配器-&gt;高级-&gt;MAC地址-&gt;生成</p>\n<h3 id=\"修改主机名\"><a href=\"#修改主机名\" class=\"headerlink\" title=\"修改主机名\"></a>修改主机名</h3><p>出于程序开发的需要，需要区别各个服务器的名称，所以修改新系统的主机名称，它默认是：localhost.localdomain</p>\n<table>\n<thead>\n<tr>\n<th>hostname</th>\n<th>查看系统主机名称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>hostnamectl set-hostname xxx</td>\n<td>修改系统主机名称<br/>1、主机名称中的特殊字符或空白字符都将会被移除，大写字母会自动转化成小写<br/>2、执行命令之后，会自动修改 &#x2F;etc&#x2F;hostname 文件<br/>3、执行命令之后，会立即生效，且重启系统也会生效</td>\n</tr>\n<tr>\n<td>cat &#x2F;etc&#x2F;hostname</td>\n<td>查看 &#x2F;etc&#x2F;hostname 文件内容，里面配置的就是系统主机名称</td>\n</tr>\n</tbody></table>\n<h3 id=\"IP-地址修改\"><a href=\"#IP-地址修改\" class=\"headerlink\" title=\"IP 地址修改\"></a>IP 地址修改</h3><blockquote>\n<p>如果是静态地址的话需要手动修改一下ip地址，如果是DHCP动态分配则无需配置。</p>\n</blockquote>\n<h4 id=\"查看网络信息\"><a href=\"#查看网络信息\" class=\"headerlink\" title=\"查看网络信息\"></a>查看网络信息</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ifconfig<br></code></pre></td></tr></table></figure>\n\n<p>假如是静态  ip，则可以手动修改 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F; 目录下的网卡文件，如 ifcfg-ens33（ifcfg-是前缀，ens33是网卡名称），网卡名称可以使用 ifconfig 命令查看。静态 ip 时，BOOTPROTO&#x3D;”static”，还会多一行 IPADDR&#x3D;x.x.x.x，修改此 IPADDR 即可修改 ip 地址。</p>\n<p><font color=\"#c00000\">特别提醒：如果克隆出来的新系统的网卡文件名称仍然和原系统的网卡名称一致，则需要手动修改文件名称为新系统的网卡名称，同时也要修改网卡文件内的 NAME、DEVICE 属性和新系统网卡名称一致。</font></p>\n<h4 id=\"重启网络\"><a href=\"#重启网络\" class=\"headerlink\" title=\"重启网络\"></a>重启网络</h4><p>使用 nmcli c reload（centos 8） 命令或 service network restart (centos 7)命令重启虚拟网卡，查看本机 ip 如果不是设置的则重启虚拟机</p>\n<h3 id=\"删除网卡信息\"><a href=\"#删除网卡信息\" class=\"headerlink\" title=\"删除网卡信息\"></a>删除网卡信息</h3><p>如果上述配置完了还有问题，就把网卡信息文件删掉重启，当然你也可以在配置的时候就直接删掉网卡信息，他在重启的时候会自动生成。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">rm</span> -rf /etc/udev/rules.d/70-persistent-ipoib.rules <br></code></pre></td></tr></table></figure>\n\n<h3 id=\"重启虚拟机\"><a href=\"#重启虚拟机\" class=\"headerlink\" title=\"重启虚拟机\"></a>重启虚拟机</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">init 6<br></code></pre></td></tr></table></figure>\n\n<p>此时就可以正常应用已经克隆好的虚拟机了。</p>\n",
            "tags": [
                "LINUX",
                "VMware"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/%E5%B7%A5%E5%85%B7/Alibaba-Cloud-Toolkit/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/%E5%B7%A5%E5%85%B7/Alibaba-Cloud-Toolkit/",
            "title": "Alibaba Cloud Toolkit",
            "date_published": "2023-05-28T13:00:29.416Z",
            "content_html": "<hr>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><ul>\n<li>Alibaba Cloud Toolkit（后文简称Cloud Toolkit）可以帮助开发者更高效地<strong>部署、测试、开发和诊断应用</strong>。</li>\n<li>Cloud Toolkit与主流IDE(IDEA, Eclipse等)及阿里云其他产品<strong>无缝集成</strong>，帮助您简化应用部署到服务器。</li>\n<li>您还可以通过其内嵌的Arthas程序诊断、Terminal Shell终端和MySQL执行器等工具，简化应用开发、测试和诊断的过程。</li>\n</ul>\n<blockquote>\n<p>缘由：由于博猪最近开发新项目，牵扯到各系统的更改，再加上本次更改牵扯到基础架构相关的表结构，慎重起见，博猪迁移了一套内网环境，方便开发联调测试。</p>\n<p>本文章基于<a href=\"https://help.aliyun.com/product/29966.html\">Alibaba Cloud Toolkit官方使用教程整理</a></p>\n</blockquote>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><ol>\n<li>在IntelliJ IDEA顶部菜单栏中选择File &gt; Settings。</li>\n<li>在Settings对话框的左侧导航栏中单击Plugins。</li>\n<li>在Plugins区域单击Marketplace。</li>\n<li>在搜索栏中输入<code>Alibaba Cloud Toolkit</code>。</li>\n<li>等待下载、安装完成后，单击Restart IDE。</li>\n</ol>\n<blockquote>\n<p>基于其他方式安装Cloud Toolkit如下:</p>\n<ul>\n<li><a href=\"https://help.aliyun.com/document_detail/29970.html?spm=a2c4g.11186623.6.551.3e2266fa2nf2fD\">基于Eclipse安装Cloud Toolkit</a></li>\n<li><a href=\"https://help.aliyun.com/document_detail/154213.html?spm=a2c4g.11186623.6.552.15772d6duW8x64\">基于Visual Studio Code安装Cloud Toolkit</a></li>\n<li><a href=\"https://help.aliyun.com/document_detail/112740.html?spm=a2c4g.11186623.6.553.73803da4coYWsV\">基于PyCharm安装Cloud Toolkit</a></li>\n</ul>\n</blockquote>\n<blockquote>\n<p>注意：</p>\n<p>如果服务器是Windows, 需要我们安装OpenSSL, 安装步骤可参考<a href=\"https://www.cnblogs.com/xijun-gu/p/16476708.html\">Windows上安装配置SSH</a></p>\n</blockquote>\n<h1 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h1><h2 id=\"Alibaba-Cloud-Toolkit-部署到本地服务器\"><a href=\"#Alibaba-Cloud-Toolkit-部署到本地服务器\" class=\"headerlink\" title=\"Alibaba Cloud Toolkit 部署到本地服务器\"></a>Alibaba Cloud Toolkit 部署到本地服务器</h2><h3 id=\"选择部署服务器类别，本文主要演示部署内网服务器，所以选择第一选项\"><a href=\"#选择部署服务器类别，本文主要演示部署内网服务器，所以选择第一选项\" class=\"headerlink\" title=\"选择部署服务器类别，本文主要演示部署内网服务器，所以选择第一选项\"></a>选择部署服务器类别，本文主要演示部署内网服务器，所以选择第一选项</h3><p><img src=\"http://tva1.sinaimg.cn/large/0086NgqGly1h4uhpvqyznj30ga0a478t.jpg\" alt=\"image.png\"></p>\n<h3 id=\"添加内网服务器配置\"><a href=\"#添加内网服务器配置\" class=\"headerlink\" title=\"添加内网服务器配置\"></a>添加内网服务器配置</h3><p><img src=\"http://tva1.sinaimg.cn/large/0086NgqGly1h4uhsk8pelj30hm0fjjtz.jpg\" alt=\"image.png\"></p>\n<p><img src=\"http://tva1.sinaimg.cn/large/0086NgqGly1h4uhuo3z8zj30hm0fj773.jpg\" alt=\"image.png\"></p>\n<p><img src=\"http://tva1.sinaimg.cn/large/0086NgqGly1h4uhzs55mhj30k40f6n31.jpg\" alt=\"image.png\"></p>\n<h3 id=\"部署项目\"><a href=\"#部署项目\" class=\"headerlink\" title=\"部署项目\"></a>部署项目</h3><h4 id=\"项目增加配置\"><a href=\"#项目增加配置\" class=\"headerlink\" title=\"项目增加配置\"></a>项目增加配置</h4><p><img src=\"http://tva1.sinaimg.cn/large/0086NgqGly1h4uj1glancj30f306qgnr.jpg\" alt=\"image.png\"></p>\n<p><img src=\"http://tva1.sinaimg.cn/large/0086NgqGly1h4uj2ewr7mj308m0eu0wb.jpg\" alt=\"image.png\"></p>\n<p><img src=\"http://tva1.sinaimg.cn/large/0086NgqGly1h4ujbbe946j30t00jg7b4.jpg\" alt=\"image.png\"></p>\n<blockquote>\n<p>注意SpringCloud项目，Maven多模块打包需要单独配置打包项目。</p>\n<p><img src=\"http://tva1.sinaimg.cn/large/0086NgqGly1h4ujdpclfoj30kj0b2ad9.jpg\" alt=\"image.png\"></p>\n<p><img src=\"http://tva1.sinaimg.cn/large/0086NgqGly1h4ujep6ew7j30q105dgns.jpg\" alt=\"image.png\"></p>\n<p><img src=\"http://tva1.sinaimg.cn/large/0086NgqGly1h4ujfv4nhij30m704jjsl.jpg\" alt=\"image.png\"></p>\n<p>例如博猪本项目最终配置如下：</p>\n<p><img src=\"http://tva1.sinaimg.cn/large/0086NgqGly1h4ujgt79zzj30t00jggqf.jpg\" alt=\"image.png\"></p>\n</blockquote>\n<h4 id=\"部署脚本\"><a href=\"#部署脚本\" class=\"headerlink\" title=\"部署脚本\"></a>部署脚本</h4><blockquote>\n<p>博猪提供一个博猪常用的docker部署脚本。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">配置镜像名称s</span><br>img=cloud-tool-test<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">配置镜像标签(版本)</span><br>tag=v1.0.0<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">配置容器名称</span><br>container=cloud-tool-test<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">判断容器是否存在，存在则删除。</span><br>if sudo docker ps -a --filter name=^/$container$ | grep -i &quot;$container&quot;; then<br>  echo &quot;容器: $container 存在，删除容器.&quot;<br>  sudo docker stop &quot;$container&quot;<br>  sudo docker rm -f &quot;$container&quot;<br>else<br>  echo &quot;容器: $container 不存在&quot; <br>fi<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">判断镜像是否存在，如存在则删除</span><br>if sudo docker images --filter=reference=&quot;$img:$tag&quot; | grep -i &quot;$img&quot;; then<br>  echo &quot;镜像: $img:$tag 镜像存在, 删除镜像重新构建.&quot;<br>  sudo docker rmi $img:$tag<br>fi<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">构建新镜像</span><br>echo &quot;构建镜像....................&quot;<br>sudo docker build -t $img:$tag .<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">启动服务，挂载外部数据信息</span><br>echo &quot;启动容器服务!&quot;<br>sudo docker run -d -p 8888:8080 --net=host --restart=always --name $container $img:$tag<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">检测服务是否启动成功</span><br>if sudo docker ps --filter name=^/$container$ | grep -i &quot;up&quot;; then<br>    echo &quot;服务启动成功....................&quot;<br>else<br>    echo &quot;服务启动失败....................&quot;<br>fi<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"部署-1\"><a href=\"#部署-1\" class=\"headerlink\" title=\"部署\"></a>部署</h4><p>选中服务器配置运行即可。</p>\n<p><img src=\"http://tva1.sinaimg.cn/large/0086NgqGly1h4ujo9olblj309w01n3ym.jpg\" alt=\"image.png\"></p>\n",
            "tags": [
                "LINUX",
                "IDEA",
                "Alibaba Cloud Toolkit"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Linux/Jenkins/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Linux/Jenkins/",
            "title": "Jenkins",
            "date_published": "2023-05-28T13:00:29.414Z",
            "content_html": "<blockquote>\n<p>持续集成：Continuous Integration，简称CI，意思是，在一个项目中，任何人对代码库的任何改动，都会触发CI服务器自动对项目进行构建，自动运行测试，甚至自动部署到测试环境。这样做的好处就是，随时发现问题，随时修复。因为修复问题的成本随着时间的推移而增长，越早发现，修复成本越低。</p>\n</blockquote>\n<h1 id=\"持续集成工具\"><a href=\"#持续集成工具\" class=\"headerlink\" title=\"持续集成工具\"></a>持续集成工具</h1><h2 id=\"Travis-CI\"><a href=\"#Travis-CI\" class=\"headerlink\" title=\"Travis CI\"></a>Travis CI</h2><p>在线托管的CI服务，用Travis来进行持续集成，不需要自己搭服务器，在网页上点几下就好，用起来更方便。最重要的是，它对开源项目是免费的。私有项目会收费。</p>\n<h2 id=\"Jenkins\"><a href=\"#Jenkins\" class=\"headerlink\" title=\"Jenkins\"></a>Jenkins</h2><p>Jenkins是一个用Java编写的开源的持续集成工具。官方网站：<a href=\"https://jenkins.io/\">https://jenkins.io/</a><br>Jenkins能实时监控持续集成过程中所存在的问题，提供详细的日志文件和提醒功能，还能用图表的形式，形象地展示项目构建的趋势和稳定性。</p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Jenkins自动化部署可以解决集成、测试、部署等重复性的工作，工具集成的效率明显高于人工操作；并且持续集成可以更早的获取代码变更的信息，从而更早的进入测试阶段，更早的发现问题，这样解决问题的成本就会显著下降：持续集成缩短了从开发、集成、测试、部署各个环节的时间，从而也就缩短了中间出现的等待时间；持续集成也意味着开发、集成、测试、部署得以持续。。<br>使用Maven（Ant）等来实现lava项目自动化构建发布部署。这些工具可以帮助在构建过程中实现自动化发布、回滚等动作。</p>\n<blockquote>\n<p>Jenkins提供Docker、war等部署方式，博猪比较倾向于yum源安装方式，同时作为一个服务启动。</p>\n</blockquote>\n<h1 id=\"安装教程\"><a href=\"#安装教程\" class=\"headerlink\" title=\"安装教程\"></a>安装教程</h1><h2 id=\"系统要求\"><a href=\"#系统要求\" class=\"headerlink\" title=\"系统要求\"></a>系统要求</h2><p>最低推荐配置:</p>\n<ul>\n<li>256MB可用内存</li>\n<li>1GB可用磁盘空间(作为一个Docker容器运行jenkins的话推荐10GB)</li>\n</ul>\n<p>为小团队推荐的硬件配置:</p>\n<ul>\n<li>1GB+可用内存</li>\n<li>50 GB+ 可用磁盘空间</li>\n</ul>\n<p>软件配置:</p>\n<ul>\n<li>Java 8—无论是Java运行时环境（JRE）还是Java开发工具包（JDK）都可以。</li>\n</ul>\n<blockquote>\n<p><strong>注意:</strong> 如果将Jenkins作为Docker 容器运行，这不是必需的</p>\n</blockquote>\n<h2 id=\"下载Jenkins\"><a href=\"#下载Jenkins\" class=\"headerlink\" title=\"下载Jenkins\"></a>下载Jenkins</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo wget -O /etc/yum.repos.d/jenkins.repo \\<br>    https://pkg.jenkins.io/redhat/jenkins.repo<br>sudo rpm --import https://pkg.jenkins.io/redhat/jenkins.io.key<br>sudo yum upgrade<br>sudo yum install epel-release java-11-openjdk-devel<br>sudo yum install jenkins<br>sudo systemctl daemon-reload<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"查看Jenkins状态\"><a href=\"#查看Jenkins状态\" class=\"headerlink\" title=\"查看Jenkins状态\"></a>查看Jenkins状态</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo systemctl status jenkins<br></code></pre></td></tr></table></figure>\n\n<p>如果是开启状态，关闭，以便更改配置。关闭命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo systemctl stop jenkins<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"自定义配置\"><a href=\"#自定义配置\" class=\"headerlink\" title=\"自定义配置\"></a>自定义配置</h2><blockquote>\n<p>配置路径如下：  &#x2F;etc&#x2F;sysconfig</p>\n</blockquote>\n<h3 id=\"自定义配置路径\"><a href=\"#自定义配置路径\" class=\"headerlink\" title=\"自定义配置路径\"></a>自定义配置路径</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">JENKINS_HOME=&quot;/opt/jenkins&quot;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"自定义默认用户\"><a href=\"#自定义默认用户\" class=\"headerlink\" title=\"自定义默认用户\"></a>自定义默认用户</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">JENKINS_USER=&quot;root&quot;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"自定义访问路径\"><a href=\"#自定义访问路径\" class=\"headerlink\" title=\"自定义访问路径\"></a>自定义访问路径</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">JENKINS_PORT=&quot;9955&quot;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"重启-amp-amp-启动Jenkins服务\"><a href=\"#重启-amp-amp-启动Jenkins服务\" class=\"headerlink\" title=\"重启&amp;&amp;启动Jenkins服务\"></a>重启&amp;&amp;启动Jenkins服务</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo systemctl start jenkins<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"访问-amp-amp-解锁Jenkins\"><a href=\"#访问-amp-amp-解锁Jenkins\" class=\"headerlink\" title=\"访问&amp;&amp;解锁Jenkins\"></a>访问&amp;&amp;解锁Jenkins</h2><blockquote>\n<p>访问地址为：linux+端口号，如上配置为：<code>http://192.168.56.121:9955</code>，访问后，进入一下配置页面。</p>\n</blockquote>\n<p><img src=\"https://i.loli.net/2021/10/04/Fwx6D1kGHqt2ogX.png\" alt=\"image-20211004202424221\"></p>\n<p>按照上方提示，输入一下命令,输入密码：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cat /opt/jenkins/secrets/initialAdminPassword<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"按照插件\"><a href=\"#按照插件\" class=\"headerlink\" title=\"按照插件\"></a>按照插件</h2><p>默认按照推荐按照即可。</p>\n<p><img src=\"https://i.loli.net/2021/10/04/EZwmnHSxribWpd5.png\" alt=\"image-20211004203303329\"></p>\n<h2 id=\"初始化用户\"><a href=\"#初始化用户\" class=\"headerlink\" title=\"初始化用户\"></a>初始化用户</h2><blockquote>\n<p>创建初始化用户，用户名：opser,密码：admin</p>\n</blockquote>\n<p><img src=\"https://i.loli.net/2021/10/04/OEiDtgdlAYW65kz.png\" alt=\"image-20211004204936715\"></p>\n<p>Jenkins初始URL默认不进行配置</p>\n<p><img src=\"https://i.loli.net/2021/10/04/YRJmbgUFoj1xhnB.png\" alt=\"image-20211004205136257\"></p>\n<h2 id=\"安装完成，开始使用\"><a href=\"#安装完成，开始使用\" class=\"headerlink\" title=\"安装完成，开始使用\"></a>安装完成，开始使用</h2><p><img src=\"https://i.loli.net/2021/10/04/kdETlSe1rw7N5py.png\" alt=\"image-20211004205218802\"></p>\n<h1 id=\"Jenkins优化\"><a href=\"#Jenkins优化\" class=\"headerlink\" title=\"Jenkins优化\"></a>Jenkins优化</h1><h2 id=\"插件优化\"><a href=\"#插件优化\" class=\"headerlink\" title=\"插件优化\"></a>插件优化</h2><blockquote>\n<p>由于Jenkins默认使用国外的镜像，所以插件下载安装速度极慢，所以我们需要更改插件仓库。</p>\n<p><strong>注意：该仓库更改必须要在没有下载插件之前！</strong></p>\n</blockquote>\n<ul>\n<li><p>进入Jenkins目录，<code>/opt/jenkins</code></p>\n</li>\n<li><p>复制并重命名文件<code>hudson.model.UpdateCenter.xml</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cp hudson.model.UpdateCenter.xml hudson.model.UpdateCenter.xml.bak<br></code></pre></td></tr></table></figure></li>\n<li><p>修改<code>hudson.model.UpdateCenter.xml</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">url改为<br>https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json<br></code></pre></td></tr></table></figure></li>\n<li><p>修改<code>default.json</code></p>\n</li>\n<li><p>配置default.json</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">vim /var/lib/jenkins/updates/default.json<br></code></pre></td></tr></table></figure></li>\n<li><p>全局替换</p>\n<blockquote>\n<p>把  updates.jenkins-ci.org&#x2F;download  替换为  mirrors.tuna.tsinghua.edu.cn&#x2F;jenkins</p>\n<p>地址修改把  <code>www.google.com</code> 替换为  <code>www.baidu.com</code></p>\n</blockquote>\n</li>\n<li><p>重启服务</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl restart jenkins<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"页面优化\"><a href=\"#页面优化\" class=\"headerlink\" title=\"页面优化\"></a>页面优化</h2><blockquote>\n<p>装完Jenkins之后，我们发现有一部分菜单汉化了，有一部分菜单没有汉化，这让人很不爽，所以我们需要调整一下让页面保持统一！</p>\n</blockquote>\n<ul>\n<li><code>系统管理</code>-<code>插件管理</code>-<code>已安装</code>，中搜索，<code>Localization: Chinese (Simplified)</code></li>\n<li>卸载，重装，同时安装<code>locale</code>插件</li>\n<li><code>系统管理</code>-<code>系统配置</code>-<code>Locale</code>-<code>Default Language</code>,填写<code>zh_CN</code>,勾选<code>Ignore browser preference and force this language to all users</code></li>\n<li>重启</li>\n</ul>\n<h1 id=\"Jenkins操作\"><a href=\"#Jenkins操作\" class=\"headerlink\" title=\"Jenkins操作\"></a>Jenkins操作</h1><h2 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h2><h3 id=\"配置一览\"><a href=\"#配置一览\" class=\"headerlink\" title=\"配置一览\"></a>配置一览</h3><p><img src=\"https://i.loli.net/2021/10/05/KNfwrISu3cqpzoB.jpg\" alt=\"img\"></p>\n<h3 id=\"构建环境配置\"><a href=\"#构建环境配置\" class=\"headerlink\" title=\"构建环境配置\"></a>构建环境配置</h3><p>指定构建时所依赖的环境参数，如jdk版本，可以手动安装jdk，也可以在【全局工具配置】中指定好jdk版本，在首次构建时会自动安装，首次构建下载时间较长，耐心等待即可。</p>\n<p>以NodeJS自动安装为例：</p>\n<p><img src=\"https://i.loli.net/2021/10/05/w3ypsOPzqZ4QM2d.jpg\" alt=\"img\"></p>\n<h2 id=\"插件管理\"><a href=\"#插件管理\" class=\"headerlink\" title=\"插件管理\"></a>插件管理</h2><p>构建模块大多以插件形式存在，使用前需安装，否则无法找到对应构建项。</p>\n<p><img src=\"https://i.loli.net/2021/10/05/BQ7LWwcZgriysMS.jpg\" alt=\"img\"></p>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><p>系统管理-&gt;系统配置-&gt;Publish over SSH，点击[新增]按钮添加服务器，按要求填写服务器信息，如果没有找到此选项，可先在【插件管理】中安装Publish over SSH插件。</p>\n<p><img src=\"https://i.loli.net/2021/10/05/e96JzP8iSpvhcy7.jpg\" alt=\"img\"></p>\n<p>说明：Remote Directory指定的目录会作为文件上传时的根目录。</p>\n<h2 id=\"Java应用构建配置\"><a href=\"#Java应用构建配置\" class=\"headerlink\" title=\"Java应用构建配置\"></a>Java应用构建配置</h2><h3 id=\"新建任务\"><a href=\"#新建任务\" class=\"headerlink\" title=\"新建任务\"></a>新建任务</h3><p>以构建Maven项目为例，选择一个Maven构建风格，可以省去许多maven配置，如果已经有一个相同配置，可选择输入名称进行复制。</p>\n<p>Maven setting.xml配置文件：</p>\n<blockquote>\n<p>&#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;tools&#x2F;hudson.tasks.Maven_MavenInstallation&#x2F;maven&#x2F;conf&#x2F;</p>\n</blockquote>\n<p><img src=\"https://i.loli.net/2021/10/05/QqhzG2svYTgujEN.jpg\" alt=\"img\"></p>\n<h3 id=\"构建包留存策略\"><a href=\"#构建包留存策略\" class=\"headerlink\" title=\"构建包留存策略\"></a>构建包留存策略</h3><p><img src=\"https://i.loli.net/2021/10/05/BsxnbpaRHl6qdGM.jpg\" alt=\"img\"></p>\n<h3 id=\"源码仓库\"><a href=\"#源码仓库\" class=\"headerlink\" title=\"源码仓库\"></a>源码仓库</h3><p>正式环境采用参数化构建，只用Git参数指定构建tag分支，默认master分支</p>\n<p><img src=\"https://i.loli.net/2021/10/05/zMtvPDfjFoXyO8S.jpg\" alt=\"img\"></p>\n<p>配置源码仓库，指定动态tag分支</p>\n<p><img src=\"https://i.loli.net/2021/10/05/sSY6haTOtJcqI2M.jpg\" alt=\"img\"></p>\n<h3 id=\"自动构建选项\"><a href=\"#自动构建选项\" class=\"headerlink\" title=\"自动构建选项\"></a>自动构建选项</h3><p>取消触发自动构建的选项</p>\n<p><img src=\"https://i.loli.net/2021/10/05/RBLYzZElcywuX7U.jpg\" alt=\"img\"></p>\n<h3 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h3><p><img src=\"https://i.loli.net/2021/10/05/i84axClGu2AokXY.jpg\" alt=\"img\"></p>\n<p>在jekenis服务器本地构建，使用jekenis服务器的maven配置进行编译构建</p>\n<h3 id=\"上传\"><a href=\"#上传\" class=\"headerlink\" title=\"上传\"></a>上传</h3><p>构建成功后上传到指定部署服务器，仅编译成功后进行上传</p>\n<p><img src=\"https://i.loli.net/2021/10/05/xyuPw2FXsRdIDpL.jpg\" alt=\"img\"></p>\n<ul>\n<li>Name：在服务列表中选择上传目标；</li>\n<li>Source files：指定上传的jar包，支持正则通配（根据构建目录距离jar包位置的不同，会自动在服务器端创建不同深度的目录）。</li>\n<li>Remote directory：可以指定上传目录，目录位于配置服务器时指定的根目录之下。</li>\n<li>Exec command：上传成功后在上传后的服务器上执行的命令或脚本。</li>\n</ul>\n<blockquote>\n<p>注：整体涉及到的编译脚本详见“项目编译脚本”</p>\n</blockquote>\n<h2 id=\"Js应用构建\"><a href=\"#Js应用构建\" class=\"headerlink\" title=\"Js应用构建\"></a>Js应用构建</h2><h3 id=\"新建任务-1\"><a href=\"#新建任务-1\" class=\"headerlink\" title=\"新建任务\"></a>新建任务</h3><p>选择一个自由风格的构建</p>\n<p><img src=\"https://i.loli.net/2021/10/05/W48lXhm1DkjRvag.jpg\" alt=\"img\"></p>\n<h3 id=\"构建包留存策略-1\"><a href=\"#构建包留存策略-1\" class=\"headerlink\" title=\"构建包留存策略\"></a>构建包留存策略</h3><p><img src=\"https://i.loli.net/2021/10/05/5XyWcCawtzI9JlV.jpg\" alt=\"img\"></p>\n<h3 id=\"源码仓库-1\"><a href=\"#源码仓库-1\" class=\"headerlink\" title=\"源码仓库\"></a>源码仓库</h3><p>正式环境采用参数化构建，只用Git参数指定构建tag分支，默认master分支</p>\n<p><img src=\"https://i.loli.net/2021/10/05/zMtvPDfjFoXyO8S.jpg\" alt=\"img\"></p>\n<p>配置源码仓库，指定动态tag分支</p>\n<p><img src=\"https://i.loli.net/2021/10/06/sgqaEWYKMb5rA8z.png\" alt=\"image-20211006134146871\"></p>\n<h3 id=\"自动构建选项-1\"><a href=\"#自动构建选项-1\" class=\"headerlink\" title=\"自动构建选项\"></a>自动构建选项</h3><p>取消自动构建选项</p>\n<p><img src=\"https://i.loli.net/2021/10/05/WUG6PSjmNKFaH37.jpg\" alt=\"img\"></p>\n<h3 id=\"构建环境\"><a href=\"#构建环境\" class=\"headerlink\" title=\"构建环境\"></a>构建环境</h3><p>指定构建环境，选择已配置的nodejs构建环境，在jekenis本地服务器进行编译构建</p>\n<p><img src=\"https://i.loli.net/2021/10/05/gcNnHvzawXFKC76.jpg\" alt=\"img\"></p>\n<h3 id=\"构建-1\"><a href=\"#构建-1\" class=\"headerlink\" title=\"构建\"></a>构建</h3><p>在jekenis本地服务器进行编译构建</p>\n<p><img src=\"https://i.loli.net/2021/10/05/j2Z4QHn5qYSolFM.jpg\" alt=\"img\"></p>\n<p>为方便后续上传，在构建环节执行了压缩命令，可视情况而定。</p>\n<blockquote>\n<p>注：整体涉及到的编译脚本详见“项目编译脚本”</p>\n</blockquote>\n<h3 id=\"上传-1\"><a href=\"#上传-1\" class=\"headerlink\" title=\"上传\"></a>上传</h3><p>将编译并压缩后的前端文件上传到指定服务器</p>\n<p><img src=\"https://i.loli.net/2021/10/05/zjxrTqCF4QGvNLH.jpg\" alt=\"img\"></p>\n<p>在服务器列表中选择目标，指定上传文件，填写上传成功后需执行的命令。因VUE编译多次会生成不同的文件，故需将编译后的文件一次性上传多个负载的服务器。</p>\n<p>即重新选择一次上传步骤：</p>\n<p><img src=\"https://i.loli.net/2021/10/05/m5ODJEU6vIx9n3L.jpg\" alt=\"img\"></p>\n<p><img src=\"https://i.loli.net/2021/10/05/2Dsf1Mg7rq4vYdn.jpg\" alt=\"img\"></p>\n<blockquote>\n<p>注：整体涉及到的编译脚本详见“项目编译脚本”</p>\n</blockquote>\n",
            "tags": [
                "CentOS",
                "Linux",
                "Jenkins"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Linux/Maven/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Linux/Maven/",
            "title": "Maven",
            "date_published": "2023-05-28T13:00:29.414Z",
            "content_html": "<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Maven是意第绪语，意思是“知识的积累者”，最初是为了简化Jakarta Turbine项目中的构建过程。有几个项目，每个项目都有自己的Ant构建文件，所有项目都略有不同。JAR已检入CVS。我们想要一种标准的方式来构建项目，清晰地定义项目的组成，一种简单的方式来发布项目信息，以及一种在多个项目中共享JAR的方式。</p>\n<p>结果是一个可以用于构建和管理任何基于Java的项目的工具。我们希望我们已经创建了一些东西，可以使Java开发人员的日常工作更加轻松，并且通常有助于理解任何基于Java的项目。</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p>Maven官网地址：<a href=\"https://maven.apache.org/\">https://maven.apache.org/</a></p>\n<p><img src=\"https://i.loli.net/2021/10/06/wi56hbVS1LqjZYd.png\" alt=\"image-20211006143204542\"></p>\n<p>进入上方官网地址，点击左侧<code>Download</code>，进入下载页面。</p>\n<p><img src=\"https://i.loli.net/2021/10/06/km3iteEFAHdKxsz.png\" alt=\"image-20211006143351772\"></p>\n<p>右键点击超链接，复制链接地址。</p>\n<p>链接服务器，进入安装目录,博猪安装在：<code>/opt</code></p>\n<p>使用<code>wget</code>进行下载，如果没有<code>wget</code>，请使用<code>yum -y install wget</code>先用yum安装。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">wget https://dlcdn.apache.org/maven/maven-3/3.8.3/binaries/apache-maven-3.8.3-bin.tar.gz<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"解压\"><a href=\"#解压\" class=\"headerlink\" title=\"解压\"></a>解压</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">tar -zxvf apache-maven-3.8.3-bin.tar.gz<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"配置环境变量\"><a href=\"#配置环境变量\" class=\"headerlink\" title=\"配置环境变量\"></a>配置环境变量</h2><p>进入<code>/etc/profile.d/</code>目录，增加<code>maven.sh</code>环境脚本。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">vim maven.sh<br></code></pre></td></tr></table></figure>\n\n<p>增加环境变量</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\"><span class=\"hljs-built_in\">export</span> MAVEN_HOME=/opt/apache-maven-3.8.3<br><span class=\"hljs-built_in\">export</span> PATH=<span class=\"hljs-variable\">$&#123;MAVEN_HOME&#125;</span>/bin:<span class=\"hljs-variable\">$&#123;PATH&#125;</span><br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：如果是以普通用户身份运行，则需要增加可执行权限</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sh\">sudo <span class=\"hljs-built_in\">chmod</span> +x /etc/profile.d/maven.sh<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>使用<code>source</code>命令加载环境变量：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">source /etc/profile.d/maven.sh<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"验证安装\"><a href=\"#验证安装\" class=\"headerlink\" title=\"验证安装\"></a>验证安装</h2><p>想要验证 Maven 软件安装，使用<code>mvn -version</code>命令，它将会打印出 Maven 版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mvn -version<br></code></pre></td></tr></table></figure>\n\n<p>你将会看到类似下面的输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">Apache Maven 3.8.3 (cecedd343002696d0abb50b32b541b8a6ba2883f)<br>Maven home: /opt/apache-maven-3.8.3<br>Java version: 11.0.5, vendor: Oracle Corporation, runtime: /usr/lib/jvm/java-11-openjdk-11.0.5.10-0.el8_0.x86_64<br>Default locale: en_US, platform encoding: UTF-8<br>OS name: &quot;linux&quot;, version: &quot;4.18.0-80.7.1.el8_0.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"配置国内镜像仓库\"><a href=\"#配置国内镜像仓库\" class=\"headerlink\" title=\"配置国内镜像仓库\"></a>配置国内镜像仓库</h1><p>配置maven仓库，设置阿里镜像仓库，一定要配置一下，国内的下载jar快些。</p>\n<p>设置本地仓库存储地址：<code>/opt/apache-maven-3.8.3/repo</code>,进入配置路径</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cd /opt/apache-maven-3.8.3/conf<br>vi settings.xml<br></code></pre></td></tr></table></figure>\n\n<p>修改仓库存储地址</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">&lt;localRepository&gt;<span class=\"hljs-regexp\">/opt/</span>apache-maven-<span class=\"hljs-number\">3.8</span>.<span class=\"hljs-number\">3</span><span class=\"hljs-regexp\">/repo&lt;/</span>localRepository&gt;<br></code></pre></td></tr></table></figure>\n\n<p>修改镜像仓库</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mirror</span>&gt;</span><br>      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">id</span>&gt;</span>alimaven<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">id</span>&gt;</span><br>      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">name</span>&gt;</span>aliyun maven<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">name</span>&gt;</span><br>       <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">url</span>&gt;</span><br>      <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">mirrorOf</span>&gt;</span>central<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mirrorOf</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure>\n",
            "tags": [
                "CentOS",
                "Linux",
                "Maven"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Linux/Crontab-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Linux/Crontab-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/",
            "title": "Crontab-定时任务",
            "date_published": "2023-05-28T13:00:29.413Z",
            "content_html": "<h1 id=\"Linux-Crontab-定时任务\"><a href=\"#Linux-Crontab-定时任务\" class=\"headerlink\" title=\"Linux Crontab 定时任务\"></a>Linux Crontab 定时任务</h1><blockquote>\n<p>很多时候，我们需要定时执行某个应用或者某段脚本，在linux上，可以使用cron服务，它有点类似于Windows上的任务计划程序。</p>\n</blockquote>\n<h2 id=\"crond和crontab\"><a href=\"#crond和crontab\" class=\"headerlink\" title=\"crond和crontab\"></a>crond和crontab</h2><p>首先需要分清楚两个概念：crond和crontab。crond是后台守护进程的名称（d代表daemon），用来实际执行脚本，它在系统中是一直运行的。可以通过下面的方式查看到它：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl | grep crond<br></code></pre></td></tr></table></figure>\n\n<p>crontab是一个工具，用来列出cron中当前运行的作业（应用或脚本等）、向cron中添加作业、编辑作业、删除作业。它并不是一直在后台运行的，是一个短时的命令行工具，执行完就结束了。</p>\n<p>可以简单理解crond和crontab组合起来提供cron服务。</p>\n<p>大体流程如下：</p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2F634d76f98ad0252888ea044489e3d5bf.png&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1627445494&t=e65617a03bb7ecea66217142dd0da756\" alt=\"img\"></p>\n<h2 id=\"crontab配置文件\"><a href=\"#crontab配置文件\" class=\"headerlink\" title=\"crontab配置文件\"></a>crontab配置文件</h2><p>Linux下的任务调度分为两类：系统任务调度和用户任务调度。Linux系统任务是由 cron (crond) 这个系统服务来控制的，这个系统服务是默认启动的。用户自己设置的计划任务则使用crontab命令。使用以下命令进行查看：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cat /etc/crontab<br></code></pre></td></tr></table></figure>\n\n<p>配置文件可以看到如下解释：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">SHELL=/bin/bash<br>PATH=/sbin:/bin:/usr/sbin:/usr/bin<br>MAILTO=root<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">For details see man 4 crontabs</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Example of job definition:</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">.---------------- minute (0 - 59)</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">|  .------------- hour (0 - 23)</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">|  |  .---------- day of month (1 - 31)</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">|  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">|  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">|  |  |  |  |</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">*  *  *  *  * user-name  <span class=\"hljs-built_in\">command</span> to be executed</span><br></code></pre></td></tr></table></figure>\n\n<p>前四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash；第二行PATH变量指定了系统执行命令的路径；第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户；第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。</p>\n<p>用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 &#x2F;var&#x2F;spool&#x2F;cron目录中。其文件名与用户名一致。</p>\n<h2 id=\"crontab文件含义\"><a href=\"#crontab文件含义\" class=\"headerlink\" title=\"crontab文件含义\"></a>crontab文件含义</h2><p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：<br>minute hour day month week command</p>\n<p><img src=\"https://www.linuxprobe.com/wp-content/uploads/2016/09/crontab.png\"></p>\n<p>在以上各个字段中，还可以使用以下特殊字符：</p>\n<p>“<em>&quot;代表所有的取值范围内的数字，如月份字段为</em>，则表示1到12个月；</p>\n<p>“&#x2F;“代表每一定时间间隔的意思，如分钟字段为*&#x2F;10，表示每10分钟执行1次。</p>\n<p>“-“代表从某个区间范围，是闭区间。如“2-5”表示“2,3,4,5”，小时字段中0-23&#x2F;2表示在0~23点范围内每2个小时执行一次。</p>\n<p>“,”分散的数字（不一定连续），如1,2,3,4,7,9。</p>\n<p>注：由于各个地方每周第一天不一样，因此Sunday&#x3D;0（第一天）或Sunday&#x3D;7（最后1天）。</p>\n<h2 id=\"crontab命令详解\"><a href=\"#crontab命令详解\" class=\"headerlink\" title=\"crontab命令详解\"></a>crontab命令详解</h2><blockquote>\n<p>因为crond是一个守护进程，所以在系统开机后，通过<code>systemctl start crond</code>启动一次以后（默认自动启动的），几乎就不需要再管它了，之后的操作都通过crontab来完成。</p>\n</blockquote>\n<h3 id=\"查看现有任务\"><a href=\"#查看现有任务\" class=\"headerlink\" title=\"查看现有任务\"></a>查看现有任务</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">crontab -l</span><br>no crontab for root<br></code></pre></td></tr></table></figure>\n\n<p>因为现在没有任务，所以显示的是 no crontab for root，可见，任务是根据用户进行区分的。</p>\n<h3 id=\"添加定时任务\"><a href=\"#添加定时任务\" class=\"headerlink\" title=\"添加定时任务\"></a>添加定时任务</h3><p>为了便于测试，我们可以创建这样一个简单的脚本(位于~&#x2F;tmp&#x2F;job1.sh)：在一个文件末尾追加当前时间。脚本如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">date +&#x27;%F %T&#x27; &gt;&gt; ~/tmp/job1.log<br></code></pre></td></tr></table></figure>\n\n<p>创建完成后记得赋予一下执行权限：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\"><span class=\"hljs-built_in\">chmod</span> 755 job1.sh</span><br></code></pre></td></tr></table></figure>\n\n<p>接下来，需要配置多久运行一次。这里通过cron表达式来设置，它非常灵活，可以很简单也可以很复杂。cron表达式的应用广泛，不止用在系统层面，在其他各种编程语言的类库当中，都有类似的实现，语法略有不同。使用下面的命令可以查看linux系统中cron表达式的写法：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\"><span class=\"hljs-built_in\">cat</span> /etc/crontab</span> <br>SHELL=/bin/bash<br>PATH=/sbin:/bin:/usr/sbin:/usr/bin<br>MAILTO=root<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">For details see man 4 crontabs</span><br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">Example of job definition:</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">.---------------- minute (0 - 59)</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">|  .------------- hour (0 - 23)</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">|  |  .---------- day of month (1 - 31)</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">|  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">|  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">|  |  |  |  |</span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">*  *  *  *  * user-name  <span class=\"hljs-built_in\">command</span> to be executed</span><br></code></pre></td></tr></table></figure>\n\n<p>如果需要查看更详细的用法，可以使用 <code># man crontab</code> 命令查看。</p>\n<p>整理后如下表所示：</p>\n<blockquote>\n<p><strong>注意：</strong>不同的cron应用存在很大差异，比如crontab不支持“秒”，特殊字符也支持的比较少（支持,-*&#x2F;）。而其他一些应用，则支持“秒”和更多的特殊字符。这里为了更完备一些，所以全都列出来了，省的以后再去总结。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th align=\"left\">名称</th>\n<th align=\"left\">必须</th>\n<th align=\"left\">取值范围</th>\n<th align=\"left\">可设置的特殊字符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">分</td>\n<td align=\"left\">是</td>\n<td align=\"left\">0-59</td>\n<td align=\"left\">,-*&#x2F;</td>\n</tr>\n<tr>\n<td align=\"left\">时</td>\n<td align=\"left\">是</td>\n<td align=\"left\">0-23</td>\n<td align=\"left\">,-*&#x2F;</td>\n</tr>\n<tr>\n<td align=\"left\">日(月)</td>\n<td align=\"left\">是</td>\n<td align=\"left\">1-31</td>\n<td align=\"left\">,-*?&#x2F;LW</td>\n</tr>\n<tr>\n<td align=\"left\">月</td>\n<td align=\"left\">是</td>\n<td align=\"left\">1-12 或者 jan-dec</td>\n<td align=\"left\">,-*&#x2F;</td>\n</tr>\n<tr>\n<td align=\"left\">日(周)</td>\n<td align=\"left\">是</td>\n<td align=\"left\">0-7（0和7都是星期天） 或者 sun-sat</td>\n<td align=\"left\">,-*?&#x2F;L#</td>\n</tr>\n<tr>\n<td align=\"left\">年</td>\n<td align=\"left\">否</td>\n<td align=\"left\">留空，1970-2099</td>\n<td align=\"left\">,-*&#x2F;</td>\n</tr>\n</tbody></table>\n<p>几个特殊字符的含义：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字符</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">*</td>\n<td align=\"left\">全部。意思是在该时间的任意点都应当执行</td>\n</tr>\n<tr>\n<td align=\"left\">?</td>\n<td align=\"left\">不指定，任意。仅用于 日(月)和日(周)。0 0 5 * ? 代表每个月的第5天零点，不论星期几。 0 0 ? * 1 代表每周一，不论是当月的哪天。</td>\n</tr>\n<tr>\n<td align=\"left\">,</td>\n<td align=\"left\">多个值的分隔符，例如1,5,10</td>\n</tr>\n<tr>\n<td align=\"left\">-</td>\n<td align=\"left\">代表连续值，例如1-20</td>\n</tr>\n<tr>\n<td align=\"left\">&#x2F;</td>\n<td align=\"left\">步长。例如 5&#x2F;15，代表从5开始，以15为步长。因此，当5&#x2F;15位于分钟的位置时，表示小时内的第5、20、35和50分钟。</td>\n</tr>\n<tr>\n<td align=\"left\">L</td>\n<td align=\"left\">最后一天。可以是每月最后一天或者每周最后一天。如果用在 天(周)字段，并且前面加数字，则表示最后一个周N。例如5L，表示最后一个周五（5表示周五，L表示最后）。</td>\n</tr>\n<tr>\n<td align=\"left\">W</td>\n<td align=\"left\">工作日，指周一到周五的任意一天</td>\n</tr>\n<tr>\n<td align=\"left\">#</td>\n<td align=\"left\">表示第几个的意思，例如 6#3，表示当月第3个星期六（6表示周六，3表示第3个）</td>\n</tr>\n</tbody></table>\n<p>几个简单的例子：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">表达式</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">* * * * *</td>\n<td align=\"left\">每分钟执行一次</td>\n</tr>\n<tr>\n<td align=\"left\">30 * * * *</td>\n<td align=\"left\">每小时的30分执行一次</td>\n</tr>\n<tr>\n<td align=\"left\">*&#x2F;5 * * * *</td>\n<td align=\"left\">每5分钟执行一次</td>\n</tr>\n<tr>\n<td align=\"left\">0&#x2F;5 * * * *</td>\n<td align=\"left\">每5分钟执行一次，且仅在0,5,15,20…55分执行</td>\n</tr>\n<tr>\n<td align=\"left\">5 0 * * *</td>\n<td align=\"left\">每天的00:05执行一次</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>注意：</strong>crontab中 日(周)不接受“?”的写法，在很多其他应用中则可以，例如Quartz.Net库：<a href=\"https://www.quartz-scheduler.net/documentation/quartz-2.x/tutorial/crontrigger.html\">https://www.quartz-scheduler.net/</a></p>\n</blockquote>\n<blockquote>\n<p><strong>提示：</strong>更多的用法，可以参考：<a href=\"https://crontab.guru/\">https://crontab.guru</a></p>\n</blockquote>\n<p>接下来，如果我们想要每分钟执行一下前面创建的job1.sh脚本，需要再创建一个crontab作业(jobs.cron，后缀名无所谓，这里只是为了便于识别)，其中包含了cron表达式，用于表明job1.sh执行的周期：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">* * * * * ~/tmp/job1.sh<br></code></pre></td></tr></table></figure>\n\n<p>使用crontab将它加入到计划中：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">crontab jobs.cron</span><br></code></pre></td></tr></table></figure>\n\n<p>再次查看当前计划，可以看到这样的结果：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">crontab -l</span><br>* * * * * ~/tmp/job1.sh<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"删除定时任务\"><a href=\"#删除定时任务\" class=\"headerlink\" title=\"删除定时任务\"></a>删除定时任务</h3><p>先将job1.sh复制一份，稍作修改，然后编辑一下jobs.cron，将job2.sh也加入进去：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">* * * * * ~/tmp/job1.sh<br>*/5 * * * * ~/tmp/job2.sh<br></code></pre></td></tr></table></figure>\n\n<p>然后重新加入到cron服务中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">crontab jobs.cron</span><br></code></pre></td></tr></table></figure>\n\n<p>接着查看一下当前cron中的作业：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">crontab -l</span><br>* * * * * ~/tmp/job1.sh<br>*/5 * * * * ~/tmp/job2.sh<br></code></pre></td></tr></table></figure>\n\n<p>可以看到上面有job1.sh和job2.sh两个作业，其效果相当于将jobs.cron文件的内容拷贝进去。</p>\n<p>如果想要删除作业，则执行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">crontab -r</span><br></code></pre></td></tr></table></figure>\n\n<p>这样会删除所有作业，如果只想删除一个，或者想对作业进行编辑，可以使用下面的命令。</p>\n<h3 id=\"编辑定时任务\"><a href=\"#编辑定时任务\" class=\"headerlink\" title=\"编辑定时任务\"></a>编辑定时任务</h3><p><code>crontab -e</code> 命令会调用编辑器（通常是vi或者vim），直接编辑计划作业，相当于编辑jobs.cron。只不过编辑完立即生效，不需要再执行crontab进行加载。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">crontab -e</span><br>crontab: installing new crontab<br></code></pre></td></tr></table></figure>\n\n<p>统一期间，个人不建议使用crontab -e编辑计划，而是编辑jobs.cron，然后进行加载。这样的话jobs.cron文件相当于一个备份，方便日后恢复。</p>\n<h2 id=\"查看作业日志\"><a href=\"#查看作业日志\" class=\"headerlink\" title=\"查看作业日志\"></a>查看作业日志</h2><p>在作业执行出现异常（或作业脚本写日志）时，cron服务会输出日志，在我的CentOS7系统上，查看的地址位于&#x2F;var&#x2F;log下。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\"><span class=\"hljs-built_in\">ls</span> /var/log | grep cron</span><br>cron<br>cron-20180819<br>cron-20180826<br>cron-20180902<br>cron-20180909<br></code></pre></td></tr></table></figure>\n\n<p>如果想让自己编写的作业输出日志，可以这样编写jobs.cron：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">* * * * * ~/tmp/job1.sh &gt;&gt; /var/log/job1.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure>\n\n<p>上面的意思是将stdout和stderr输出到&#x2F;var&#x2F;log&#x2F;job1.log。</p>\n<p>修改job1.sh，在底部加入<code>echo hello</code>。然后调用<code>crontab jobs.cron</code>重新加载，然后在&#x2F;var&#x2F;log目录下可以看到job1.log，其中包含了输出的文本“hello”。</p>\n",
            "tags": [
                "CentOS",
                "Linux",
                "Crontab"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Linux/Centos7/Centos7-MongoDB/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Linux/Centos7/Centos7-MongoDB/",
            "title": "Centos7-MongoDB",
            "date_published": "2023-05-28T13:00:29.412Z",
            "content_html": "<h1 id=\"离线安装\"><a href=\"#离线安装\" class=\"headerlink\" title=\"离线安装\"></a>离线安装</h1><h2 id=\"下载安装包\"><a href=\"#下载安装包\" class=\"headerlink\" title=\"下载安装包\"></a>下载安装包</h2><p>根据自己的要求下载tar包，<a href=\"https://www.mongodb.com/try/download/community2\">点击此链接选择进行下载</a></p>\n<p>博猪下载版本为<code>mongodb-linux-x86_64-rhel70-4.4.17.tgz</code></p>\n<h2 id=\"上传安装包\"><a href=\"#上传安装包\" class=\"headerlink\" title=\"上传安装包\"></a>上传安装包</h2><h2 id=\"解压压缩包\"><a href=\"#解压压缩包\" class=\"headerlink\" title=\"解压压缩包\"></a>解压压缩包</h2><p>解压到 &#x2F;opt 目录下，并重命名</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">tar zxvf mongodb-linux-x86_64-rhel70-4.4.17.tgz -C /opt<br><br>mv mongodb-linux-x86_64-rhel70-6.0.0 mongodb<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"配置环境变量\"><a href=\"#配置环境变量\" class=\"headerlink\" title=\"配置环境变量\"></a>配置环境变量</h2><p>在 &#x2F;etc&#x2F;profile 中加入下面一行：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">export PATH=/opt/mongodb/bin:$PATH<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">刷新配置</span><br>source /etc/profile<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"创建数据库目录和日志目录\"><a href=\"#创建数据库目录和日志目录\" class=\"headerlink\" title=\"创建数据库目录和日志目录\"></a>创建数据库目录和日志目录</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mkdir -p /opt/mongodb/logs  # 日志目录<br>mkdir -p /opt/mongodb/db  # 数据库目录<br><br>touch /opt/mongodb/logs/mongodb.log  # 创建日志文件<br>chmod 777 /opt/mongodb/logs<br>chmod 777 /opt/mongodb/db<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"创建配置文件\"><a href=\"#创建配置文件\" class=\"headerlink\" title=\"创建配置文件\"></a>创建配置文件</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">vi /opt/mongodb/mongodb.conf<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs properties\"><span class=\"hljs-attr\">port</span>= <span class=\"hljs-string\">27017</span><br><span class=\"hljs-attr\">dbpath</span>=<span class=\"hljs-string\">/opt/mongodb/db  # 指定数据库路径</span><br><span class=\"hljs-attr\">logpath</span>=<span class=\"hljs-string\">/opt/mongodb/logs/mongodb.log # 指定日志文件路径</span><br><span class=\"hljs-attr\">logappend</span>=<span class=\"hljs-string\">true  # 使用追加方式写日志</span><br><span class=\"hljs-attr\">fork</span>=<span class=\"hljs-string\">true  # 以守护进程的方式运行</span><br><span class=\"hljs-attr\">maxConns</span>=<span class=\"hljs-string\">100  # 最大同时连接数</span><br><span class=\"hljs-attr\">noauth</span>=<span class=\"hljs-string\">true  # 不启用验证</span><br><span class=\"hljs-attr\">journal</span>=<span class=\"hljs-string\">true  # 每次写入会记录一条操作日志</span><br><span class=\"hljs-attr\">storageEngine</span>=<span class=\"hljs-string\">wiredTiger # 存储引擎</span><br><span class=\"hljs-attr\">bind_ip</span>=<span class=\"hljs-string\">0.0.0.0 # 服务绑定地址</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"启动mongodb\"><a href=\"#启动mongodb\" class=\"headerlink\" title=\"启动mongodb\"></a>启动mongodb</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mongod --config /opt/mongodb/mongodb.conf<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"启用授权验证\"><a href=\"#启用授权验证\" class=\"headerlink\" title=\"启用授权验证\"></a>启用授权验证</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mongod --config /opt/mongodb/mongodb.conf --auth<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"停止-mongodb\"><a href=\"#停止-mongodb\" class=\"headerlink\" title=\"停止 mongodb\"></a>停止 mongodb</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mongod --config /opt/mongodb/mongodb.conf --shutdown<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"配置开机启动\"><a href=\"#配置开机启动\" class=\"headerlink\" title=\"配置开机启动\"></a>配置开机启动</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">vim /etc/init.d/mongodb<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">!/bin/sh</span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\"></span><br><span class=\"language-bash\"><span class=\"hljs-comment\">#chkconfig: 2345 80 90</span></span><br><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">description: mongodb</span><br>start() &#123;<br> /opt/mongodb/bin/mongod --config /opt/mongodb/mongodb.conf<br>&#125;<br> <br>stop() &#123;<br>  /opt/mongodb/bin/mongod --config /opt/mongodb/mongodb.conf --shutdown<br>&#125;<br> <br>case &quot;$1&quot; in<br>  start)<br> start<br> ;;<br>  stop)<br> stop<br> ;;<br>  restart)<br> stop<br> start<br> ;;<br>  *)<br> echo $&quot;Usage: $0 &#123;start|stop|restart&#125;&quot;<br> exit 1<br>esac<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cd /etc/init.d/<br><br>sudo chkconfig --add mongodb<br>sudo chmod +x  mongodb<br>sudo chkconfig mongodb on<br></code></pre></td></tr></table></figure>\n\n<p>配置完成后可使用以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">启动mongodb：</span><br>service mongodb start<br><span class=\"hljs-meta prompt_\"></span><br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">停止mongodb：</span><br>service mongodb stop<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：上述启动为root账户启动，权限太大，如果需要启用验证，则需要将配置文件（&#x2F;opt&#x2F;mongodb&#x2F;mongodb.conf）中的 noauth 设置为 false</p>\n</blockquote>\n<h1 id=\"Yum源安装\"><a href=\"#Yum源安装\" class=\"headerlink\" title=\"Yum源安装\"></a>Yum源安装</h1><h2 id=\"创建存储源文件夹\"><a href=\"#创建存储源文件夹\" class=\"headerlink\" title=\"创建存储源文件夹\"></a>创建存储源文件夹</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mkdir -p /opt/rpm_repo<br>cd /opt/rpm_repo\t<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"下载MongoDBYum源\"><a href=\"#下载MongoDBYum源\" class=\"headerlink\" title=\"下载MongoDBYum源\"></a>下载MongoDBYum源</h2><blockquote>\n<p>根据自己的要求下载tar包，<a href=\"https://www.mongodb.com/try/download/community2\">点击此链接选择进行下载</a>,选择一下三个选项，右键<code>Download</code>,复制链接地址即可。</p>\n<p><img src=\"http://tva1.sinaimg.cn/large/0086NgqGly1h7acvnupi8j313d0mp7ak.jpg\" alt=\"image.png\"></p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">shell-rpm</span><br>wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.4/x86_64/RPMS/mongodb-org-shell-4.4.17-1.el7.x86_64.rpm<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">server-rpm</span><br>wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.4/x86_64/RPMS/mongodb-org-server-4.4.17-1.el7.x86_64.rpm<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">mongos-rpm</span><br>wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.4/x86_64/RPMS/mongodb-org-mongos-4.4.17-1.el7.x86_64.rpm<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用Yum安装\"><a href=\"#使用Yum安装\" class=\"headerlink\" title=\"使用Yum安装\"></a>使用Yum安装</h2><blockquote>\n<p>使用 yum 安装 mongodb，可以解决依赖包问题</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">yum install -y mongodb-org-*.rpm<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"查询MongoDB状态\"><a href=\"#查询MongoDB状态\" class=\"headerlink\" title=\"查询MongoDB状态\"></a>查询MongoDB状态</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl status mongod<br></code></pre></td></tr></table></figure>\n\n<p>如果启动，则需要停止运行，停止命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl stop mongod<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"修改MongoDB配置文件\"><a href=\"#修改MongoDB配置文件\" class=\"headerlink\" title=\"修改MongoDB配置文件\"></a>修改MongoDB配置文件</h2><ul>\n<li>备份配置文件</li>\n<li>备份配置文件</li>\n<li>备份配置文件</li>\n</ul>\n<p>重要的事情说三遍！！！！</p>\n<blockquote>\n<p>一般yum安装配置信息都在<code>/etc</code></p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cd /etc<br>cp mongod.conf mongod.conf.bak<br></code></pre></td></tr></table></figure>\n\n<p>修改配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">vi mongod.conf<br></code></pre></td></tr></table></figure>\n\n<p>最终文件配置如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-comment\"># mongod.conf</span><br><br><span class=\"hljs-comment\"># for documentation of all options, see:</span><br><span class=\"hljs-comment\">#   http://docs.mongodb.org/manual/reference/configuration-options/</span><br><br><span class=\"hljs-comment\"># where to write logging data.</span><br><span class=\"hljs-attr\">systemLog:</span><br>  <span class=\"hljs-attr\">destination:</span> <span class=\"hljs-string\">file</span><br>  <span class=\"hljs-attr\">logAppend:</span> <span class=\"hljs-literal\">true</span><br>  <span class=\"hljs-comment\"># 指定日志文件路径</span><br>  <span class=\"hljs-attr\">path:</span> <span class=\"hljs-string\">/opt/mongodb/logs/mongod.log</span><br><br><span class=\"hljs-comment\"># Where and how to store data.</span><br><span class=\"hljs-attr\">storage:</span><br>  <span class=\"hljs-comment\"># 指定数据库路径</span><br>  <span class=\"hljs-attr\">dbPath:</span> <span class=\"hljs-string\">/opt/mongodb/db</span><br>  <span class=\"hljs-comment\"># 每次写入会记录一条操作日志</span><br>  <span class=\"hljs-attr\">journal:</span><br>    <span class=\"hljs-attr\">enabled:</span> <span class=\"hljs-literal\">true</span><br><span class=\"hljs-comment\">#  engine:</span><br><span class=\"hljs-comment\">#  wiredTiger:</span><br><br><span class=\"hljs-comment\"># how the process runs</span><br><span class=\"hljs-attr\">processManagement:</span><br>  <span class=\"hljs-comment\"># 以守护进程的方式运行</span><br>  <span class=\"hljs-attr\">fork:</span> <span class=\"hljs-literal\">true</span>  <span class=\"hljs-comment\"># fork and run in background</span><br>  <span class=\"hljs-attr\">pidFilePath:</span> <span class=\"hljs-string\">/var/run/mongodb/mongod.pid</span>  <span class=\"hljs-comment\"># location of pidfile</span><br>  <span class=\"hljs-attr\">timeZoneInfo:</span> <span class=\"hljs-string\">/usr/share/zoneinfo</span><br><br><span class=\"hljs-comment\"># network interfaces</span><br><span class=\"hljs-attr\">net:</span><br>  <span class=\"hljs-comment\"># 配置端口</span><br>  <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">37017</span><br>  <span class=\"hljs-comment\"># 服务绑定地址</span><br>  <span class=\"hljs-comment\"># 输入0.0.0.0，::绑定所有IPv4和IPv6地址，或者使用网络。bindIpAll设置</span><br>  <span class=\"hljs-attr\">bindIp:</span> <span class=\"hljs-number\">0.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.0</span>  <span class=\"hljs-comment\"># Enter 0.0.0.0,:: to bind to all IPv4 and IPv6 addresses or, alternatively, use the net.bindIpAll setting.</span><br><br><br><span class=\"hljs-comment\">#security:</span><br><br><span class=\"hljs-comment\">#operationProfiling:</span><br><br><span class=\"hljs-comment\">#replication:</span><br><br><span class=\"hljs-comment\">#sharding:</span><br><br><span class=\"hljs-comment\">## Enterprise-Only Options</span><br><br><span class=\"hljs-comment\">#auditLog:</span><br><br><span class=\"hljs-comment\">#snmp:</span><br></code></pre></td></tr></table></figure>\n",
            "tags": [
                "Linux",
                "CentOS7",
                "MongoDB"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(8)-%E5%AE%89%E8%A3%85nacos/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(8)-%E5%AE%89%E8%A3%85nacos/",
            "title": "Docker(8)-安装nacos",
            "date_published": "2023-05-28T13:00:29.387Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>日常开发使用springcloud-alibaba，为个人开发方便，本地搭建一个测试环境。</p>\n</blockquote>\n<h1 id=\"安装Nacos\"><a href=\"#安装Nacos\" class=\"headerlink\" title=\"安装Nacos\"></a>安装Nacos</h1><h2 id=\"拉取镜像\"><a href=\"#拉取镜像\" class=\"headerlink\" title=\"拉取镜像\"></a>拉取镜像</h2><figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs axapta\">docker pull nacos/nacos-<span class=\"hljs-keyword\">server</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"挂载目录\"><a href=\"#挂载目录\" class=\"headerlink\" title=\"挂载目录\"></a>挂载目录</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">mkdir -p /data/nacos/logs/                      #新建logs目录<br>mkdir -p /data/nacos/init.d/          <br>vim /data/nacos/init.d/custom.properties        #修改配置文件<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"mysql新建nacos的数据库，并执行脚本\"><a href=\"#mysql新建nacos的数据库，并执行脚本\" class=\"headerlink\" title=\"mysql新建nacos的数据库，并执行脚本\"></a>mysql新建nacos的数据库，并执行脚本</h2><blockquote>\n<p><a href=\"https://github.com/alibaba/nacos/blob/master/config/src/main/resources/META-INF/nacos-db.sql\">下载地址</a></p>\n</blockquote>\n<h2 id=\"修改配置文件custom-properties\"><a href=\"#修改配置文件custom-properties\" class=\"headerlink\" title=\"修改配置文件custom.properties\"></a>修改配置文件<code>custom.properties</code></h2><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs properties\"><span class=\"hljs-attr\">server.contextPath</span>=<span class=\"hljs-string\">/nacos</span><br><span class=\"hljs-attr\">server.servlet.contextPath</span>=<span class=\"hljs-string\">/nacos</span><br><span class=\"hljs-attr\">server.port</span>=<span class=\"hljs-string\">8848</span><br><br><span class=\"hljs-attr\">spring.datasource.platform</span>=<span class=\"hljs-string\">mysql</span><br><span class=\"hljs-attr\">db.num</span>=<span class=\"hljs-string\">1</span><br><span class=\"hljs-attr\">db.url.0</span>=<span class=\"hljs-string\">jdbc:mysql://192.168.56.120:3306/nacos_devtest_prod?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span><br><span class=\"hljs-attr\">db.user</span>=<span class=\"hljs-string\">user</span><br><span class=\"hljs-attr\">db.password</span>=<span class=\"hljs-string\">pass</span><br><br><span class=\"hljs-attr\">nacos.cmdb.dumpTaskInterval</span>=<span class=\"hljs-string\">3600</span><br><span class=\"hljs-attr\">nacos.cmdb.eventTaskInterval</span>=<span class=\"hljs-string\">10</span><br><span class=\"hljs-attr\">nacos.cmdb.labelTaskInterval</span>=<span class=\"hljs-string\">300</span><br><span class=\"hljs-attr\">nacos.cmdb.loadDataAtStart</span>=<span class=\"hljs-string\">false</span><br><span class=\"hljs-attr\">management.metrics.export.elastic.enabled</span>=<span class=\"hljs-string\">false</span><br><span class=\"hljs-attr\">management.metrics.export.influx.enabled</span>=<span class=\"hljs-string\">false</span><br><span class=\"hljs-attr\">server.tomcat.accesslog.enabled</span>=<span class=\"hljs-string\">true</span><br><span class=\"hljs-attr\">server.tomcat.accesslog.pattern</span>=<span class=\"hljs-string\">%h %l %u %t &quot;%r&quot; %s %b %D %&#123;User-Agent&#125;i</span><br><span class=\"hljs-attr\">nacos.security.ignore.urls</span>=<span class=\"hljs-string\">/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/login,/v1/console/health/**,/v1/cs/**,/v1/ns/**,/v1/cmdb/**,/actuator/**,/v1/console/server/**</span><br><span class=\"hljs-attr\">nacos.naming.distro.taskDispatchThreadCount</span>=<span class=\"hljs-string\">1</span><br><span class=\"hljs-attr\">nacos.naming.distro.taskDispatchPeriod</span>=<span class=\"hljs-string\">200</span><br><span class=\"hljs-attr\">nacos.naming.distro.batchSyncKeyCount</span>=<span class=\"hljs-string\">1000</span><br><span class=\"hljs-attr\">nacos.naming.distro.initDataRatio</span>=<span class=\"hljs-string\">0.9</span><br><span class=\"hljs-attr\">nacos.naming.distro.syncRetryDelay</span>=<span class=\"hljs-string\">5000</span><br><span class=\"hljs-attr\">nacos.naming.data.warmup</span>=<span class=\"hljs-string\">true</span><br><span class=\"hljs-attr\">nacos.naming.expireInstance</span>=<span class=\"hljs-string\">true</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker  run \\<br>--name nacos -d \\<br>-p 8848:8848 \\<br>--privileged=true \\<br>--restart=always \\<br>-e JVM_XMS=256m \\<br>-e JVM_XMX=256m \\<br>-e MODE=standalone \\<br>-e PREFER_HOST_MODE=hostname \\<br>-v /data/nacos/logs:/home/nacos/logs \\<br>-v /data/nacos/init.d/custom.properties:/home/nacos/init.d/custom.properties \\<br>nacos/nacos-server<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h2><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>地址</td>\n<td>http:&#x2F;&#x2F;宿主ip:8848&#x2F;nacos</td>\n</tr>\n<tr>\n<td>用户名</td>\n<td>nacos</td>\n</tr>\n<tr>\n<td>密码</td>\n<td>nacos</td>\n</tr>\n</tbody></table>\n",
            "tags": [
                "Docker",
                "LINUX"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(7)-Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(7)-Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/",
            "title": "Docker(7)-Docker常用命令",
            "date_published": "2023-05-28T13:00:29.386Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>本人文章均引用或者复制：</p>\n<p>公众号：</p>\n<p><img src=\"http://www.cicoding.cn/icons/wx.jpg\"></p>\n<p>QQ群：<a href=\"http://shang.qq.com/wpa/qunwpa?idkey=85cfa5c4c8fbe9859b7166a33d84c32f2def325c4d29f35f299a5756a955ab21\">806951874</a></p>\n</blockquote>\n<h1 id=\"Docker常用命令大全\"><a href=\"#Docker常用命令大全\" class=\"headerlink\" title=\"Docker常用命令大全\"></a>Docker常用命令大全</h1><h2 id=\"Docker帮助命令\"><a href=\"#Docker帮助命令\" class=\"headerlink\" title=\"Docker帮助命令\"></a>Docker帮助命令</h2><blockquote>\n<p>Docker 全部命令可通过：</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker --help<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201009113009.png\" alt=\"image-20201009113001805\"></p>\n<p>比如想查看日志操作方法可使用以下命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker logs --help<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201009113238.png\" alt=\"image-20201009113237094\"></p>\n</blockquote>\n<h2 id=\"镜像常用命令\"><a href=\"#镜像常用命令\" class=\"headerlink\" title=\"镜像常用命令\"></a>镜像常用命令</h2><h3 id=\"docker-images-查看本地镜像\"><a href=\"#docker-images-查看本地镜像\" class=\"headerlink\" title=\"docker images 查看本地镜像\"></a>docker images 查看本地镜像</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker images [OPTIONS] [REPOSITORY[:TAG]]<br></code></pre></td></tr></table></figure>\n\n<p>OPTIONS说明：</p>\n<ul>\n<li><strong>-a :</strong> 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</li>\n<li><strong>-q :</strong> 只显示镜像ID。</li>\n<li><strong>–digests :</strong> 显示镜像的摘要信息；</li>\n<li><strong>–no-trunc :</strong> 显示完整的镜像信息；</li>\n<li><strong>-f :</strong> 显示满足条件的镜像；</li>\n<li><strong>–format :</strong> 指定返回值的模板文件；</li>\n</ul>\n<h3 id=\"docker-search-从Docker-Hub查找镜像\"><a href=\"#docker-search-从Docker-Hub查找镜像\" class=\"headerlink\" title=\"docker search : 从Docker Hub查找镜像\"></a>docker search : 从Docker Hub查找镜像</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker search [OPTIONS] TERM<br></code></pre></td></tr></table></figure>\n\n<p>OPTIONS说明：</p>\n<ul>\n<li><em><strong>-s :</strong></em> <strong>列出收藏数不小于指定值的镜像。</strong></li>\n<li><strong>–automated :</strong> 只列出 automated build类型的镜像；</li>\n<li><strong>–no-trunc :</strong> 显示完整的镜像描述；</li>\n</ul>\n<blockquote>\n<p>从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker search -s 10 java<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"docker-pull-从镜像仓库中拉取或者更新指定镜像\"><a href=\"#docker-pull-从镜像仓库中拉取或者更新指定镜像\" class=\"headerlink\" title=\"docker pull :  从镜像仓库中拉取或者更新指定镜像\"></a>docker pull :  从镜像仓库中拉取或者更新指定镜像</h3><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs elixir\">docker pull [<span class=\"hljs-title class_\">OPTIONS</span>] <span class=\"hljs-title class_\">NAME</span>[<span class=\"hljs-symbol\">:TAG|</span><span class=\"hljs-variable\">@DIGEST</span>]<br></code></pre></td></tr></table></figure>\n\n<p>OPTIONS说明：</p>\n<ul>\n<li><strong>-a :</strong> 拉取所有 tagged 镜像</li>\n<li><strong>–disable-content-trust :</strong> 忽略镜像的校验,默认开启</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\">#</span><span class=\"language-bash\">docker pull redis等于一下命令，latest是最新的版本，也可以指定某个版本号</span><br>docker pull redis:latest<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"docker-rmi-删除本地一个或多少镜像。\"><a href=\"#docker-rmi-删除本地一个或多少镜像。\" class=\"headerlink\" title=\"docker rmi : 删除本地一个或多少镜像。\"></a>docker rmi : 删除本地一个或多少镜像。</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker rmi [OPTIONS] IMAGE [IMAGE...]<br></code></pre></td></tr></table></figure>\n\n<p>OPTIONS说明：</p>\n<ul>\n<li><strong>-f :</strong> 强制删除；</li>\n<li><strong>–no-prune :</strong> 不移除该镜像的过程镜像，默认移除；</li>\n</ul>\n<h2 id=\"容器常用命令\"><a href=\"#容器常用命令\" class=\"headerlink\" title=\"容器常用命令\"></a>容器常用命令</h2><h3 id=\"docker-run-：创建一个新的容器并运行一个命令\"><a href=\"#docker-run-：创建一个新的容器并运行一个命令\" class=\"headerlink\" title=\"docker run ：创建一个新的容器并运行一个命令\"></a>docker run ：创建一个新的容器并运行一个命令</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]<br></code></pre></td></tr></table></figure>\n\n<p>OPTIONS说明：</p>\n<ul>\n<li><em><strong>-d:</strong></em>  <strong>后台运行容器，并返回容器ID;</strong></li>\n<li><em><strong>–name&#x3D;&quot;nginx-lb&quot;:</strong></em>  <strong>为容器指定一个名称；</strong></li>\n<li><em><strong>-p:</strong></em> <strong>指定端口映射，格式为：主机(宿主)端口:容器端口</strong></li>\n<li><em><strong>–volume , -v:</strong></em>  <strong>绑定一个卷</strong></li>\n<li><em><strong>-i:</strong></em> <strong>以交互模式运行容器，通常与 -t 同时使用；</strong></li>\n<li><strong>-a stdin:</strong>  指定标准输入输出内容类型，可选 STDIN&#x2F;STDOUT&#x2F;STDERR 三项；</li>\n<li><strong>-P:</strong>  随机端口映射，容器内部端口<strong>随机</strong>映射到主机的高端口</li>\n<li><strong>-t:</strong>  为容器重新分配一个伪输入终端，通常与 -i 同时使用；</li>\n<li><strong>–dns 8.8.8.8:</strong>  指定容器使用的DNS服务器，默认和宿主一致；</li>\n<li><strong>–dns-search example.com:</strong>  指定容器DNS搜索域名，默认和宿主一致；</li>\n<li><strong>-h &quot;mars&quot;:</strong>  指定容器的hostname；</li>\n<li><strong>-e username&#x3D;&quot;ritchie&quot;:</strong>  设置环境变量；</li>\n<li><strong>–env-file&#x3D;[]:</strong>  从指定文件读入环境变量；</li>\n<li>–env key&#x3D;value 添加配置变量</li>\n<li><strong>–cpuset&#x3D;&quot;0-2&quot; or –cpuset&#x3D;&quot;0,1,2&quot;:</strong>  绑定容器到指定CPU运行；</li>\n<li><strong>-m :</strong> 设置容器使用内存最大值；</li>\n<li><strong>–net&#x3D;&quot;bridge&quot;:</strong>  指定容器的网络连接类型，支持 bridge&#x2F;host&#x2F;none&#x2F;container:&lt;name|id&gt; 四种类型；</li>\n<li><strong>–link&#x3D;[]:</strong>  添加链接到另一个容器；</li>\n<li><strong>–expose&#x3D;[]:</strong>  开放一个端口或一组端口；</li>\n</ul>\n<h3 id=\"docker-ps-查看当前运行容器\"><a href=\"#docker-ps-查看当前运行容器\" class=\"headerlink\" title=\"docker ps  查看当前运行容器\"></a>docker ps  查看当前运行容器</h3><p><img src=\"http://www.cicoding.cn/images/docker/1527507117875-46795fe1-3255-46c0-a2bc-6bde4b1e51dd.png\" alt=\"在Docker中安装JDK\"></p>\n<h3 id=\"docker-exec-：-在运行的容器中执行命令\"><a href=\"#docker-exec-：-在运行的容器中执行命令\" class=\"headerlink\" title=\"docker exec ： 在运行的容器中执行命令\"></a>docker exec ： 在运行的容器中执行命令</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]　　<br></code></pre></td></tr></table></figure>\n\n<p>OPTIONS说明：</p>\n<ul>\n<li><em><strong>-i :</strong></em> <strong>即使没有附加也保持STDIN 打开</strong></li>\n<li><em><strong>-t :</strong></em> <strong>分配一个伪终端</strong></li>\n<li><strong>-d :</strong> 分离模式: 在后台运行</li>\n</ul>\n<h3 id=\"docker-start-x2F-stop-x2F-restart-docker-启动、停止、重启\"><a href=\"#docker-start-x2F-stop-x2F-restart-docker-启动、停止、重启\" class=\"headerlink\" title=\"docker start&#x2F;stop&#x2F;restart (docker 启动、停止、重启)\"></a>docker start&#x2F;stop&#x2F;restart (docker 启动、停止、重启)</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker kill CONTAINER 强制停止<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"退出容器-exit\"><a href=\"#退出容器-exit\" class=\"headerlink\" title=\"退出容器 exit\"></a>退出容器 exit</h3><h3 id=\"删除container\"><a href=\"#删除container\" class=\"headerlink\" title=\"删除container\"></a>删除container</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker rm 镜像名称或者容器id(container)<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>批量删除 docker rm -f | $(docker ps -a -q)和docker ps -a -q | xargs docker rm</p>\n</blockquote>\n<h3 id=\"docker-logs-获取容器的日志\"><a href=\"#docker-logs-获取容器的日志\" class=\"headerlink\" title=\"docker logs :  获取容器的日志\"></a>docker logs :  获取容器的日志</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker logs [OPTIONS] CONTAINER<br></code></pre></td></tr></table></figure>\n\n<p>OPTIONS说明：</p>\n<ul>\n<li><strong>-f :</strong>  跟踪日志输出</li>\n<li><strong>-t :</strong>  显示时间戳</li>\n<li>**–tail : **仅列出最新N条容器日志</li>\n<li><strong>–since :</strong> 显示某个开始时间的所有日志</li>\n</ul>\n<blockquote>\n<p>查看nexus最新的200条实时日志：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker logs -f --tail=200 nexus3<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201009114334.png\" alt=\"image-20201009114332847\"></p>\n</blockquote>\n<h3 id=\"docker-top-查看容器中运行的进程信息，支持-ps-命令参数。\"><a href=\"#docker-top-查看容器中运行的进程信息，支持-ps-命令参数。\" class=\"headerlink\" title=\"docker top : 查看容器中运行的进程信息，支持 ps 命令参数。\"></a>docker top : 查看容器中运行的进程信息，支持 ps 命令参数。</h3><p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201009140626.png\"></p>\n<p>查看所有运行容器的进程信息。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">for i in  `docker ps |grep Up|awk &#x27;&#123;print $1&#125;&#x27;`;do echo \\ &amp;&amp;docker top $i; done<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"docker-inspect-获取容器-x2F-镜像的元数据。\"><a href=\"#docker-inspect-获取容器-x2F-镜像的元数据。\" class=\"headerlink\" title=\"docker inspect :  获取容器&#x2F;镜像的元数据。\"></a>docker inspect :  获取容器&#x2F;镜像的元数据。</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker inspect [OPTIONS] NAME|ID [NAME|ID...]<br></code></pre></td></tr></table></figure>\n\n<p>OPTIONS说明：</p>\n<ul>\n<li><strong>-f :</strong> 指定返回值的模板文件。</li>\n<li>**-s : **显示总的文件大小。</li>\n<li><strong>–type :</strong> 为指定类型返回JSON。</li>\n</ul>\n<p>查看当前容器分配的ip</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201009140650.png\" alt=\"img\"></p>\n<h3 id=\"docker-cp-用于容器与主机之间的数据拷贝。\"><a href=\"#docker-cp-用于容器与主机之间的数据拷贝。\" class=\"headerlink\" title=\"docker cp : 用于容器与主机之间的数据拷贝。\"></a>docker cp : 用于容器与主机之间的数据拷贝。</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-<br>docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH<br></code></pre></td></tr></table></figure>\n\n<p>OPTIONS说明：</p>\n<ul>\n<li><strong>-L :</strong> 保持源目标中的链接</li>\n</ul>\n<blockquote>\n<p>实例</p>\n</blockquote>\n<blockquote>\n<p>将主机&#x2F;www&#x2F;runoob目录拷贝到容器96f7f14e99ab的&#x2F;www目录下。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker cp /www/runoob 96f7f14e99ab:/www/<br></code></pre></td></tr></table></figure>\n\n<p>将容器96f7f14e99ab的&#x2F;www目录拷贝到主机的&#x2F;tmp目录中。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker cp  96f7f14e99ab:/www /tmp/<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h2 id=\"DockerFile\"><a href=\"#DockerFile\" class=\"headerlink\" title=\"DockerFile\"></a>DockerFile</h2><h3 id=\"docker-build-命令用于使用-Dockerfile-创建镜像。\"><a href=\"#docker-build-命令用于使用-Dockerfile-创建镜像。\" class=\"headerlink\" title=\"docker build  命令用于使用 Dockerfile 创建镜像。\"></a>docker build  命令用于使用 Dockerfile 创建镜像。</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker build [OPTIONS] PATH | URL | -<br></code></pre></td></tr></table></figure>\n\n<p>OPTIONS说明：</p>\n<ul>\n<li><strong>–build-arg&#x3D;[] :</strong> 设置镜像创建时的变量；</li>\n<li><strong>–cpu-shares :</strong> 设置 cpu 使用权重；</li>\n<li><strong>–cpu-period :</strong> 限制 CPU CFS周期；</li>\n<li><strong>–cpu-quota :</strong> 限制 CPU CFS配额；</li>\n<li><strong>–cpuset-cpus :</strong> 指定使用的CPU id；</li>\n<li><strong>–cpuset-mems :</strong> 指定使用的内存 id；</li>\n<li><strong>–disable-content-trust :</strong> 忽略校验，默认开启；</li>\n<li><strong>-f :</strong> 指定要使用的Dockerfile路径；</li>\n<li><strong>–force-rm :</strong> 设置镜像过程中删除中间容器；</li>\n<li><strong>–isolation :</strong> 使用容器隔离技术；</li>\n<li><strong>–label&#x3D;[] :</strong> 设置镜像使用的元数据；</li>\n<li><strong>-m :</strong> 设置内存最大值；</li>\n<li><strong>–memory-swap :</strong> 设置Swap的最大值为内存+swap，”-1”表示不限swap；</li>\n<li><strong>–no-cache :</strong> 创建镜像的过程不使用缓存；</li>\n<li><strong>–pull :</strong> 尝试去更新镜像的新版本；</li>\n<li><strong>–quiet, -q :</strong> 安静模式，成功后只输出镜像 ID；</li>\n<li><strong>–rm :</strong> 设置镜像成功后删除中间容器；</li>\n<li><strong>–shm-size :</strong> 设置&#x2F;dev&#x2F;shm的大小，默认值是64M；</li>\n<li><strong>–ulimit :</strong> Ulimit配置。</li>\n<li><strong>–tag, -t:</strong>  镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</li>\n<li><strong>–network:</strong>  默认 default。在构建期间设置RUN指令的网络模式</li>\n</ul>\n<blockquote>\n<p>实例</p>\n</blockquote>\n<blockquote>\n<p>使用当前目录的 Dockerfile 创建镜像，标签为 runoob&#x2F;ubuntu:v1。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker build -t runoob/ubuntu:v1 .<br></code></pre></td></tr></table></figure>\n<p>使用URL <strong>github.com&#x2F;creack&#x2F;docker-firefox</strong> 的 Dockerfile 创建镜像。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker build github.com/creack/docker-firefox<br></code></pre></td></tr></table></figure>\n<p>也可以通过 -f Dockerfile 文件的位置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker build -f /path/to/a/Dockerfile .<br></code></pre></td></tr></table></figure>\n</blockquote>\n",
            "tags": [
                "Docker",
                "LINUX"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(6)-%E5%AE%89%E8%A3%85Nginx/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(6)-%E5%AE%89%E8%A3%85Nginx/",
            "title": "Docker(6)-安装Nginx",
            "date_published": "2023-05-28T13:00:29.386Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>本人文章均引用或者复制：</p>\n<p>公众号：</p>\n<p><img src=\"http://www.cicoding.cn/icons/wx.jpg\"></p>\n<p>QQ群：<a href=\"http://shang.qq.com/wpa/qunwpa?idkey=85cfa5c4c8fbe9859b7166a33d84c32f2def325c4d29f35f299a5756a955ab21\">806951874</a></p>\n</blockquote>\n<h1 id=\"在Docker中安装Nginx\"><a href=\"#在Docker中安装Nginx\" class=\"headerlink\" title=\"在Docker中安装Nginx\"></a>在Docker中安装Nginx</h1><h2 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>由于nginx是一个反向代理服务器，涉及到一些配置。如果你对nginx一点都不懂的话，那么，你在学习下面的内容的时候，可能就会不太懂，因为我们是要在docker中操作nginx，同时需要编辑一些配置文件。</p>\n<p>适合对于nginx有一定了解的朋友参考使用。</p>\n</blockquote>\n<h2 id=\"下载nginx镜像\"><a href=\"#下载nginx镜像\" class=\"headerlink\" title=\"下载nginx镜像\"></a>下载nginx镜像</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull nginx<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"查看下载的nginx镜像\"><a href=\"#查看下载的nginx镜像\" class=\"headerlink\" title=\"查看下载的nginx镜像\"></a>查看下载的nginx镜像</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker images<br></code></pre></td></tr></table></figure>\n\n<p>如下图：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527832301031-bf1ad67d-a6a2-4c20-888e-970c41c7ae9d.png\"></p>\n<h2 id=\"启动nginx镜像容器\"><a href=\"#启动nginx镜像容器\" class=\"headerlink\" title=\"启动nginx镜像容器\"></a>启动nginx镜像容器</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -d -p 80:80 --name nginx nginx<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>nginx是一个代理，端口默认是80</p>\n</blockquote>\n<h2 id=\"访问服务器\"><a href=\"#访问服务器\" class=\"headerlink\" title=\"访问服务器\"></a>访问服务器</h2><p>在浏览器中输入：<a href=\"http://192.168.56.128/%EF%BC%8C%E5%9B%9E%E8%BD%A6%E7%9C%8B%E4%B8%80%E4%B8%8B%E6%95%88%E6%9E%9C%EF%BC%9A\">http://192.168.56.128:80/，回车看一下效果：</a></p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527832846216-4d03013e-d0cd-434f-9069-10f2e38e67bf.png\" alt=\"在Docker中安装Nginx\"></p>\n<blockquote>\n<p>出现上面的页面，说明nginx已经正常启动了。</p>\n</blockquote>\n<h2 id=\"将nginx的配置文件、日志目录映射到宿主机\"><a href=\"#将nginx的配置文件、日志目录映射到宿主机\" class=\"headerlink\" title=\"将nginx的配置文件、日志目录映射到宿主机\"></a>将nginx的配置文件、日志目录映射到宿主机</h2><blockquote>\n<p>在测试环境、生产环境的话，都是需要编辑一些nginx的配置的，最常见的修改就是nginx.conf文件。</p>\n</blockquote>\n<blockquote>\n<p>将nginx的配置文件、日志目录等，映射到宿主机上进行管理维护，是很方便的，也是推荐的做法。</p>\n</blockquote>\n<h3 id=\"在宿主机中创建nginx相关目录\"><a href=\"#在宿主机中创建nginx相关目录\" class=\"headerlink\" title=\"在宿主机中创建nginx相关目录\"></a>在宿主机中创建nginx相关目录</h3><blockquote>\n<p>首先在宿主机中创建一个用于存放nginx相关文件的目录，这里我就在 &#x2F;opt 目录下新建了一个 docker_nginx 的目录文件。</p>\n<p>然后在 docker_nginx 目录下新建 conf 、log 、www 这三个目录，目录含义是：</p>\n<p>conf：存放nginx的相关配置文件，比如 nginx.conf</p>\n<p>log：存放nginx的日志文件</p>\n<p>www：存放相关静态资源文件</p>\n</blockquote>\n<blockquote>\n<p>最终的目录结构如下：</p>\n</blockquote>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527833862890-ad0217c0-5bf3-46c9-b332-88a7b04da6ca.png\" alt=\"在Docker中安装Nginx\"></p>\n<p>复制一份nginx.conf文件到宿主机对应的目录下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker cp nginx:/etc/nginx/nginx.conf /opt/docker_nginx/conf/nginx.conf<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这条命令的作用，就是复制nginx的docker容器中的 &#x2F;etc&#x2F;nginx&#x2F;nginx.conf 文件到宿主机下的 &#x2F;opt&#x2F;docker_nginx&#x2F;conf&#x2F; 目录下。这样可以直接进行默认的配置文件的编辑。</p>\n</blockquote>\n<p>看一下默认的nginx.conf配置文件的内容：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527834624021-ba784d6a-6c4a-4d0d-a2dc-e2885999314d.png\" alt=\"在Docker中安装Nginx\"></p>\n<p>编辑 nginx 的配置文件：</p>\n<blockquote>\n<p>我们暂时就修改其中的 access_log 、error_log 、root 这些基本配置。</p>\n</blockquote>\n<blockquote>\n<p>从上图可以看到，配置文件最下面，有这样一段配置：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">include /etc/nginx/conf.d/*.conf;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>意思也就是引入了其他配置文件。</p>\n<p>既然我们要在宿主机上管理nginx的配置文件，所以对于上面的include引入的文件，我们也要复制一份到对应的宿主机上。</p>\n</blockquote>\n<blockquote>\n<p>我们进入nginx容器，去查看一下这个路径下面有哪些文件：</p>\n<ul>\n<li>进入nginx容器</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker exec -it e4 /bin/bash<br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>其中的 e4 指的是容器ID的前2位字符串。</p>\n</blockquote>\n<blockquote>\n<ul>\n<li>查看 &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F; 目录</li>\n</ul>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527835373585-7316d3b7-e789-4f62-8a6b-8c3953633697.png\" alt=\"在Docker中安装Nginx\"><a href=\"http://www.cicoding.cn/images/docker/1527835373585-7316d3b7-e789-4f62-8a6b-8c3953633697.png\">http://www.cicoding.cn/images/docker/1527835373585-7316d3b7-e789-4f62-8a6b-8c3953633697.png</a></p>\n<p>可以看到，里面有一个default.conf配置文件</p>\n<ul>\n<li>查看 default.conf配置文件</li>\n</ul>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527835468543-cbfd5cfc-ffcf-4512-abb9-46331febd3ae.png\" alt=\"在Docker中安装Nginx\"><a href=\"http://www.cicoding.cn/images/docker/1527835468543-cbfd5cfc-ffcf-4512-abb9-46331febd3ae.png\">http://www.cicoding.cn/images/docker/1527835468543-cbfd5cfc-ffcf-4512-abb9-46331febd3ae.png</a></p>\n</blockquote>\n<blockquote>\n<p>其中用黄色圈起来的部分，是我们要修改的内容（上面说过了，目前就先简单修改基本的配置，只是方便大家看到一下效果，至于其他的配置，可自行按照这样的步骤自行编辑）。</p>\n<ul>\n<li>复制一份default.conf文件到宿主机对应的目录下</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker cp nginx:/etc/nginx/conf.d/default.conf /opt/docker_nginx/conf/default.conf<br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>查看一下目前宿主机下面的nginx配置文件情况</p>\n</blockquote>\n<blockquote>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527837882497-2ef89731-6d8c-4639-b6cb-2c9d4034a2cd.png\" alt=\"在Docker中安装Nginx\"><a href=\"http://www.cicoding.cn/images/docker/1527837882497-2ef89731-6d8c-4639-b6cb-2c9d4034a2cd.png\">http://www.cicoding.cn/images/docker/1527837882497-2ef89731-6d8c-4639-b6cb-2c9d4034a2cd.png</a></p>\n<ul>\n<li>同样的，我们也需要把nginx的默认首页文件，复制到宿主机下面</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker cp nginx:/usr/share/nginx/html/index.html /opt/docker_nginx/www/<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"编辑宿主机上的nginx相关配置文件\"><a href=\"#编辑宿主机上的nginx相关配置文件\" class=\"headerlink\" title=\"编辑宿主机上的nginx相关配置文件\"></a>编辑宿主机上的nginx相关配置文件</h3><blockquote>\n<ul>\n<li><strong>首先修改 nginx.conf 配置文件</strong>，修改后结果是：</li>\n</ul>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527838034307-65530160-3710-4246-a816-9703af4fc524.png\" alt=\"在Docker中安装Nginx\"><a href=\"http://www.cicoding.cn/images/docker/1527838034307-65530160-3710-4246-a816-9703af4fc524.png\">http://www.cicoding.cn/images/docker/1527838034307-65530160-3710-4246-a816-9703af4fc524.png</a></p>\n<blockquote>\n<p>其中error_log的配置，就是我们前面在宿主机下面创建的nginx的log目录。</p>\n<p>注意需要修改最下面的include配置，指定宿主机下面的default.conf配置文件（default&#x2F;conf与nginx.conf在相同目录下，所以直接写名称即可，无需指定具体目录路径）</p>\n</blockquote>\n<ul>\n<li><strong>编辑default.conf文件</strong></li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">vim /opt/docker_nginx/conf/default.conf<br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>修改文件中的 access_log 以及 root 配置，效果如下</p>\n</blockquote>\n<blockquote>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527838387330-9501c9c8-1d8b-44e0-a177-d61a8c4699fa.png\" alt=\"在Docker中安装Nginx\"></p>\n<blockquote>\n<p>同样，access_log 以及 root 的配置，就是我们前面在宿主机下面创建的nginx的相关目录。</p>\n</blockquote>\n</blockquote>\n<h3 id=\"重启nginx容器\"><a href=\"#重启nginx容器\" class=\"headerlink\" title=\"重启nginx容器\"></a>重启nginx容器</h3><ul>\n<li><strong>先停止之前启动的nginx容器</strong></li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker stop e4s<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>重启nginx容器</strong></li>\n</ul>\n<blockquote>\n<p>这次重启nginx容器的话，就不能使用一开始那种简单的run命令了，需要添加一些参数，具体命令如下：</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -p 80:80 --name nginx-new \\<br>    -v /opt/docker_nginx/www:/usr/share/nginx/html \\<br>    -v /opt/docker_nginx/log:/var/log/nginx \\<br>    -v /opt/docker_nginx/conf/nginx.conf:/etc/nginx/conf \\<br>    -d nginx<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里的 -v 参数的含义是，将宿主机上的目录挂载到容器中的对应目录。</p>\n<p>“：”冒号前面是宿主机的目录，后面是容器中的目录。</p>\n</blockquote>\n<blockquote>\n<p>有些朋友可能会不搞不明白冒号后面的容器路径是怎么来的，这里解释一下，其实很简单，就是指的是nginx的默认的日志路径、配置文件路径。</p>\n<p>你在nginx容器中去查看一下nginx.conf以及default.conf配置文件的内容，就可以看到log和配置文件的默认存储路径了。文章上面也有截图出来nginx.conf以及default.conf的默认配置截图，可自行翻阅到上面查看。</p>\n</blockquote>\n<ul>\n<li><strong>查看启动的nginx容器</strong></li>\n</ul>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527839391119-1d98218f-62eb-46d4-8c8e-3047e30c773c.png\"></p>\n<ul>\n<li><strong>修改nginx默认首页内容</strong></li>\n</ul>\n<blockquote>\n<p>先看一下默认首页的样子：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527840233785-22a458d3-1123-4249-b671-179ccc7e41fe.png\" alt=\"在Docker中安装Nginx\"></p>\n</blockquote>\n<p>我们把这个首页内容全部删除掉，加入我们自己的内容！</p>\n<blockquote>\n<p>编辑宿主机下面的 &#x2F;opt&#x2F;docker_nginx&#x2F;www&#x2F;index.html 文件：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">vim /opt/docker_nginx/www/index.html<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>修改之后如下：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527840219657-335ad4a0-276f-47d3-b49a-0b55fa8299fd.png\" alt=\"在Docker中安装Nginx\"></p>\n<ul>\n<li>重新访问服务器域名，查看最终效果</li>\n</ul>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527841014053-e2e485f8-a08e-40d7-bc05-603c7d32d43e.png\" alt=\"在Docker中安装Nginx\"></p>\n<blockquote>\n<p>如果页面出现中文乱码的问题，可以在 index.html 好 标签里面加入：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;Content-Type&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>最终index.html文件内容如下：</p>\n</blockquote>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;Content-Type&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Welcome to nginx!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\"></span><br><span class=\"language-css\">    <span class=\"hljs-selector-tag\">body</span> &#123;</span><br><span class=\"language-css\">        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">35em</span>;</span><br><span class=\"language-css\">        <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span> auto;</span><br><span class=\"language-css\">        <span class=\"hljs-attribute\">font-family</span>: Tahoma, Verdana, Arial, sans-serif;</span><br><span class=\"language-css\">    &#125;</span><br><span class=\"language-css\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>欢迎访问!<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>当前nginx服务来源于Docker容器<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br>&lt;/html<br></code></pre></td></tr></table></figure>\n",
            "tags": [
                "Docker",
                "LINUX"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(5)-%E5%AE%89%E8%A3%85MySQL/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(5)-%E5%AE%89%E8%A3%85MySQL/",
            "title": "Docker(5)-安装MySQL",
            "date_published": "2023-05-28T13:00:29.385Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>本人文章均引用或者复制：</p>\n<p>公众号：</p>\n<p><img src=\"http://www.cicoding.cn/icons/wx.jpg\"></p>\n<p>QQ群：<a href=\"http://shang.qq.com/wpa/qunwpa?idkey=85cfa5c4c8fbe9859b7166a33d84c32f2def325c4d29f35f299a5756a955ab21\">806951874</a></p>\n</blockquote>\n<h1 id=\"在Docker中安装Mysql\"><a href=\"#在Docker中安装Mysql\" class=\"headerlink\" title=\"在Docker中安装Mysql\"></a>在Docker中安装Mysql</h1><h2 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>前言</p>\n<p>此篇幅内容较多，讲解的很详细，也有很多知识点。能耐心认真的读完，就很不错了~</p>\n</blockquote>\n<blockquote>\n<p>一般情况下，都会永久性的配置镜像加速，在Linux中修改 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件，填入以下内容：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">&#123;<br>    &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]<br>&#125;<br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>如果daemon.json不存在的话，需要自己创建一下。</p>\n<p>文件修改保存成功之后，记得重启一下Docker服务，以便让这个镜像加速生效。</p>\n<p>重启Docker服务</p>\n<p>我们在【在centos系统中安装Docker】一节中讲过Docker随着服务器重启自动启动的内容，正好可以通过命令service docker restart来实现Docker服务的重启。</p>\n<p>具体详情请查看 <a href=\"https://yuque.com/zhoubang/docker/rqspmt#cuygcr\">https://yuque.com/zhoubang/docker/rqspmt#cuygcr</a></p>\n</blockquote>\n<blockquote>\n<p>然后我们在Linux中执行命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">service docker restart<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>出现下图所示结果，表明Docker服务已经重新启动了！这样就可以永久性的使用Docker加速服务了。</p>\n<blockquote>\n<p>如果不做特别的配置的话，之前处于运行状态的容器，随着Docker服务的重启也会停止运行。</p>\n</blockquote>\n<h2 id=\"下载mysql镜像\"><a href=\"#下载mysql镜像\" class=\"headerlink\" title=\"下载mysql镜像\"></a>下载mysql镜像</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull mysql<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果配置了镜像加速，那么在下载mysql镜像或者其他比较大的文件的时候，会发现下载速度变得非常快！</p>\n</blockquote>\n<h2 id=\"启动mysql容器\"><a href=\"#启动mysql容器\" class=\"headerlink\" title=\"启动mysql容器\"></a>启动mysql容器</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --name=mysql mysql<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>其中 -e 的作用是用于设置环境变量，mysql默认用户名为root，则MYSQL_ROOT_PASSWORD即为root设置密码，即123456</p>\n</blockquote>\n<h2 id=\"查看运行的mysql容器\"><a href=\"#查看运行的mysql容器\" class=\"headerlink\" title=\"查看运行的mysql容器\"></a>查看运行的mysql容器</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker ps<br></code></pre></td></tr></table></figure>\n\n<p>如下图：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201015011544.png\"></p>\n<blockquote>\n<p>mysql容器已经正常启动了！</p>\n</blockquote>\n<h2 id=\"进入mysql容器\"><a href=\"#进入mysql容器\" class=\"headerlink\" title=\"进入mysql容器\"></a>进入mysql容器</h2><blockquote>\n<p>既然mysql服务启动了，如果我们想对mysql进行操作（比如进入命令行操作、客户端连接等操作），该怎么办？</p>\n</blockquote>\n<p><strong>通过 docker exec 命令进入mysql容器：</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker exec -it c9 /bin/bash<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>其中的“c9”指的当前mysql容器ID的前面部分值（在上图就可以看出来mysql容器的ID是 c94faeed480a）。</p>\n</blockquote>\n<p>回车运行效果如下图：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201015011544.png\" alt=\"img\"></p>\n<blockquote>\n<p>其实这个时候，命令行控制台可以输入mysql相关的命令了。</p>\n</blockquote>\n<h2 id=\"连接mysql数据库\"><a href=\"#连接mysql数据库\" class=\"headerlink\" title=\"连接mysql数据库\"></a>连接mysql数据库</h2><blockquote>\n<p>mysql -u root -p123456</p>\n</blockquote>\n<p>如下图：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201015011544.png\" alt=\"img\"></p>\n<p>这个就是我们非常熟悉的mysql命令行界面了！</p>\n<p>我们可以在这里创建数据库、表等操作。再次印证了Docker的强大和方便！</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527527324223-e0be6ce6-e27b-4ba9-9eb0-821cb8f0509e.jpeg\"></p>\n<h2 id=\"查看当前所有的数据库\"><a href=\"#查看当前所有的数据库\" class=\"headerlink\" title=\"查看当前所有的数据库\"></a>查看当前所有的数据库</h2><p>在mysql命令行中执行命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">show databases;<br></code></pre></td></tr></table></figure>\n\n<p>如下图所示：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201015012343.png\"></p>\n<blockquote>\n<p>完全就是和平常使用mysql一样。</p>\n</blockquote>\n<h2 id=\"创建数据库、表、新增测试数据\"><a href=\"#创建数据库、表、新增测试数据\" class=\"headerlink\" title=\"创建数据库、表、新增测试数据\"></a>创建数据库、表、新增测试数据</h2><h3 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create database docker_test;<br></code></pre></td></tr></table></figure>\n\n<p>效果如下图：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527527630068-b5963a1f-6e4b-4afb-90fa-6aff56bb5f2d.png\"></p>\n<blockquote>\n<p>这里我就创建了一个数据库docker_test</p>\n</blockquote>\n<h3 id=\"选择数据库\"><a href=\"#选择数据库\" class=\"headerlink\" title=\"选择数据库\"></a>选择数据库</h3><blockquote>\n<p>首先需要<strong>选择具体的数据库</strong>，执行命令选择刚刚创建的数据库：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">use docker_test<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">create table test(name varchar(20),age int(11));<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>创建了test表，有2个字段：name、age</p>\n</blockquote>\n<h3 id=\"添加测试数据\"><a href=\"#添加测试数据\" class=\"headerlink\" title=\"添加测试数据\"></a>添加测试数据</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">insert into test values(&quot;Kitty&quot;,26),(&quot;Tom&quot;,18),(&quot;Jack&quot;,36);<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这里就简单添加3条测试数据。</p>\n</blockquote>\n<blockquote>\n<p>我们查询一下数据是否存在于数据库中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">select * from test;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201015013358.png\"></p>\n</blockquote>\n<blockquote>\n<p>一切OK！</p>\n</blockquote>\n<h2 id=\"客户端连接mysql数据库\"><a href=\"#客户端连接mysql数据库\" class=\"headerlink\" title=\"客户端连接mysql数据库\"></a>客户端连接mysql数据库</h2><blockquote>\n<p>既然mysql成功启动并运行，除了能在命令行中操作mysql数据库之外，肯定也是必须要能在客户端上连接和操作数据库才行。</p>\n</blockquote>\n<blockquote>\n<p>下面我就在我本地电脑上通过数据库客户端软件连接一下这个mysql数据库， 看看能不能正常连接和操作。</p>\n</blockquote>\n<blockquote>\n<p>我使用的是IDEA自带的数据库软件</p>\n</blockquote>\n<h3 id=\"新建连接mysql数据库\"><a href=\"#新建连接mysql数据库\" class=\"headerlink\" title=\"新建连接mysql数据库\"></a>新建连接mysql数据库</h3><p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201015035759.png\"></p>\n<ul>\n<li>输入正确的mysql相关信息，连接数据库</li>\n</ul>\n<blockquote>\n<p>输入完成之后，可以点击下方的 Test Connection 按钮，来测试连接是否正常。</p>\n</blockquote>\n<p><strong>查看创建的数据库和表：</strong></p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201015040227.png\"></p>\n<blockquote>\n<p>到此，mysql的相关服务已经正常访问和操作了。这和我们传统的使用mysql没有什么不同。</p>\n</blockquote>\n<h3 id=\"客户端中操作表数据\"><a href=\"#客户端中操作表数据\" class=\"headerlink\" title=\"客户端中操作表数据\"></a>客户端中操作表数据</h3><blockquote>\n<p>我们通过DataGrip客户端，在test表中手动再添加一条数据，然后我们在docker中看看是否能查看到新增的数据：</p>\n</blockquote>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527529149115-b76ddbb0-d5d6-47c2-994a-5e6b7c86b9aa.png\" alt=\"在Docker中安装Mysql\"></p>\n<blockquote>\n<p>【注意】：我这里添加了一条带有中文的数据。</p>\n</blockquote>\n<h3 id=\"进入mysql容器中查询表数据\"><a href=\"#进入mysql容器中查询表数据\" class=\"headerlink\" title=\"进入mysql容器中查询表数据\"></a>进入mysql容器中查询表数据</h3><p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201015040555.png\"></p>\n<blockquote>\n<p>呀！是不是发现问题了~ 没错，中文乱码！怎么解决呢？</p>\n</blockquote>\n<h3 id=\"mysql容器中解决表数据中文乱码\"><a href=\"#mysql容器中解决表数据中文乱码\" class=\"headerlink\" title=\"mysql容器中解决表数据中文乱码\"></a>mysql容器中解决表数据中文乱码</h3><h4 id=\"查看mysql容器的ID\"><a href=\"#查看mysql容器的ID\" class=\"headerlink\" title=\"查看mysql容器的ID\"></a>查看mysql容器的ID</h4><p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201015011544.png\" alt=\"img\"></p>\n<h4 id=\"进入mysql的docker容器\"><a href=\"#进入mysql的docker容器\" class=\"headerlink\" title=\"进入mysql的docker容器\"></a>进入mysql的docker容器</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker exec -it 20 /bin/bash<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"编辑mysql配置文件\"><a href=\"#编辑mysql配置文件\" class=\"headerlink\" title=\"编辑mysql配置文件\"></a>编辑mysql配置文件</h4><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">vim /etc/mysql/my.cnf<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>如果提示 vim: command not found 的错误信息，需要安装相关依赖包，执行下面两个命令即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">apt-get update<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">apt-get install vim<br></code></pre></td></tr></table></figure>\n</blockquote>\n<h4 id=\"在my-cnf文件中加入以下配置\"><a href=\"#在my-cnf文件中加入以下配置\" class=\"headerlink\" title=\"在my.cnf文件中加入以下配置\"></a>在my.cnf文件中加入以下配置</h4><figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tex\">[mysqld]<br>character-set-server=utf8 <br>[client]<br>default-character-set=utf8 <br>[mysql]<br>default-character-set=utf8<br></code></pre></td></tr></table></figure>\n\n<p>最终修改结果为：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527530651772-65e37c7b-f8bd-4600-82d3-bbc899c75588.png\" alt=\"在Docker中安装Mysql\"></p>\n<p><strong>重新进入mysql容器，查询表数据</strong> ，显示结果为：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201015041908.png\"></p>\n<blockquote>\n<p>可以看到，已经正常显示中文了！</p>\n</blockquote>\n<h4 id=\"停止并重启mysql容器，再次查看效果\"><a href=\"#停止并重启mysql容器，再次查看效果\" class=\"headerlink\" title=\"停止并重启mysql容器，再次查看效果\"></a>停止并重启mysql容器，再次查看效果</h4><p><img src=\"http://www.cicoding.cn/images/docker/1527531064156-dd3d8b97-58ea-45e1-a0a3-c197f1bf4053.png\"></p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527531133633-c2fa79b6-d15b-4339-b062-ef0514e77940.png\" alt=\"在Docker中安装Mysql\"></p>\n<blockquote>\n<p>客户端连接正常！</p>\n</blockquote>\n<h4 id=\"进入mysql容器，查看表数据\"><a href=\"#进入mysql容器，查看表数据\" class=\"headerlink\" title=\"进入mysql容器，查看表数据\"></a>进入mysql容器，查看表数据</h4><p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201015085429.png\"></p>\n<blockquote>\n<p>mysql容器重启之后，查询数据正常显示中文！一切没什么问题了~</p>\n</blockquote>\n<h2 id=\"通过commit命令提交新的镜像\"><a href=\"#通过commit命令提交新的镜像\" class=\"headerlink\" title=\"通过commit命令提交新的镜像\"></a>通过commit命令提交新的镜像</h2><blockquote>\n<p>根据在mysql容器中所做的更改，创建新的mysql镜像。</p>\n<p>回想一下，我们在mysql容器中做了什么更改？</p>\n<p>创建数据库、表、新增数据、修改my.cnf配置文件，就是这些吧~</p>\n</blockquote>\n<p>使用<em><strong>commit</strong></em>命令提交新镜像</p>\n<p>通过在Linux命令行中执行命令，提交新的镜像：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker commit c9 mysql-new<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>其中，“c9”就是指的容器ID，新的镜像名称为“mysql-new”。</p>\n</blockquote>\n<p>如下图：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527531803451-9e5877e4-43d7-4661-a577-961c2332fe2d.png\" alt=\"在Docker中安装Mysql\"></p>\n<p>查看所有镜像列表：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527532053082-2e7691e6-6219-455b-906d-f4534476b913.png\" alt=\"在Docker中安装Mysql\"></p>\n<blockquote>\n<p>是不是发现了我们创建的新的镜像mysql-new了。</p>\n</blockquote>\n<h3 id=\"启动新创建的mysql镜像\"><a href=\"#启动新创建的mysql镜像\" class=\"headerlink\" title=\"启动新创建的mysql镜像\"></a>启动新创建的mysql镜像</h3><p><img src=\"http://www.cicoding.cn/images/docker/1527532239704-6e772c1c-551f-42f6-9b45-39137f38bea5.png\" alt=\"在Docker中安装Mysql\"></p>\n<blockquote>\n<p>由于上面我们已经运行了一个mysql的容器了，端口是3306，所以我们新运行一个mysql容器的时候，端口号就不能是3306了，这里我指定为3307，且容器的别名是mysql-new，方便区分查看。</p>\n</blockquote>\n<h3 id=\"进入新创建的mysql容器\"><a href=\"#进入新创建的mysql容器\" class=\"headerlink\" title=\"进入新创建的mysql容器\"></a>进入新创建的mysql容器</h3><h4 id=\"查看mysql数据库信息\"><a href=\"#查看mysql数据库信息\" class=\"headerlink\" title=\"查看mysql数据库信息\"></a>查看mysql数据库信息</h4><p><img src=\"http://www.cicoding.cn/images/docker/1527532534611-7677fed8-a17e-463c-93bb-62a1f7dfbb21.png\" alt=\"在Docker中安装Mysql\"></p>\n<h4 id=\"查看my-cnf配置文件内容\"><a href=\"#查看my-cnf配置文件内容\" class=\"headerlink\" title=\"查看my.cnf配置文件内容\"></a>查看my.cnf配置文件内容</h4><p><img src=\"http://www.cicoding.cn/images/docker/1527532760600-5a1830ab-633e-4d00-a15a-23b6c2e0d677.png\" alt=\"在Docker中安装Mysql\"></p>\n<p>从上面2张图中，可以明显的看到，我们之前创建的数据库docker_test、表test，都没有了！但是修改的my.cnf配置文件的内容还是保留着的。</p>\n<p>why？？？ 为什么会这样呢？</p>\n<blockquote>\n<p>官方文档在commit命令的介绍中，有这样一段话：</p>\n<p><strong>The commit operation will not include any data contained in volumes mounted inside the container.</strong></p>\n</blockquote>\n<blockquote>\n<p>意思是commit操作并不会包含容器内挂载数据卷中的数据。</p>\n</blockquote>\n<blockquote>\n<p><strong>如果对于“数据卷”不了解的话，确实看不懂是什么意思。</strong></p>\n</blockquote>\n<h3 id=\"数据卷与数据卷容器\"><a href=\"#数据卷与数据卷容器\" class=\"headerlink\" title=\"数据卷与数据卷容器\"></a>数据卷与数据卷容器</h3><blockquote>\n<p><strong>数据卷与数据卷容器</strong></p>\n</blockquote>\n<blockquote>\n<p>生产环境中使用Docker的过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及容器的数据管理操作。</p>\n<p>容器中管理数据主要有两种方式：</p>\n<p>数据卷（Data Volumes）：数据卷是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器。</p>\n<p>数据卷容器（Data Volume Containers）：数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷，供其他容器挂载使用的。</p>\n</blockquote>\n<p>根据官方文档对于commit的介绍中，可以猜测到为何之前创建的数据库、表都不见了，原因是因为mysql容器的挂载数据卷引起的。</p>\n<p>我们可以通过命令查看到别名是“mysql”的容器挂载数据卷的目录。</p>\n<p>看一下我们的“mysql”容器的ID信息，方便查看。</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527546716034-2e7873e1-883c-4d60-bdd6-bd75962b403a.png\" alt=\"在Docker中安装Mysql\"></p>\n<p>通过命令docker inspect查看mysql这个容器的数据卷挂载信息：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker inspect c9<br></code></pre></td></tr></table></figure>\n\n<p>执行命令之后，由于显示的内容比较多，这里我们就贴一下重要的信息：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527546766842-6a1ebb25-6a86-4a67-b202-05382a3ca083.png\" alt=\"在Docker中安装Mysql\"></p>\n<p>通过图中可以看到，mysql容器将容器内的&#x2F;var&#x2F;lib&#x2F;mysql路径作为volume挂载。真正的数据库相关数据文件所在的目录就是“Source”对应的目录，即：&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;1b0b17f6a4f78d357a187116d75991db8ee784213e67cc9b9988c8ef647fe563&#x2F;_data</p>\n<p>我们可以进入mysql容器查看&#x2F;var&#x2F;lib&#x2F;mysql目录下的内容：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527546887058-112f86c9-f2ae-4cae-9540-6da58fe3e8aa.png\" alt=\"在Docker中安装Mysql\"></p>\n<blockquote>\n<p>发现的确是mysql数据库的数据文件（红色区域）。</p>\n</blockquote>\n<p>这时候，我们切换到Linux命令行，进入到mysql容器的数据挂载目录，看看该目录下有什么内容：</p>\n<p>&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;1b0b17f6a4f78d357a187116d75991db8ee784213e67cc9b9988c8ef647fe563&#x2F;_data</p>\n<p>如下图所示：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527546977803-7124018a-3f0e-447b-88d8-80b442be4539.png\" alt=\"在Docker中安装Mysql\"></p>\n<p>咦~ 是不是发现了什么！把黄色区域的内容与上图中红色区域内容进行对比，是不是内容一模一样！</p>\n<p>这也就印证了，当初我们在mysql容器中创建的数据库、表等，真正的数据库文件存放的位置就是在宿主机下面，而不是存放在容器中。</p>\n<p>到此，我们终于知道了为何mysql-new容器中的数据库、表都不见了，原来数据库文件是存放在宿主机上的。</p>\n<p>那该如何解决这个问题呢？怎样才能让mysql-new容器启动之后可以正常加载我们之前创建的数据库、表等数据呢？这就引入了下面的正题 —— 数据挂载。</p>\n<h2 id=\"数据挂载\"><a href=\"#数据挂载\" class=\"headerlink\" title=\"数据挂载\"></a>数据挂载</h2><p>docker的数据挂载分为三种，volume、bind mount和tmpfs，关于三种的具体说明，有兴趣了解的可以看一下官网的文档 <a href=\"https://docs.docker.com/storage/\">https://docs.docker.com/storage/</a></p>\n<p>参考文档 《基于docker部署mysql的数据持久化问题》 <a href=\"https://www.jianshu.com/p/530d00f97cbf\">https://www.jianshu.com/p/530d00f97cbf</a></p>\n<blockquote>\n<p>上面的文章里面，把问题描述的非常详细清楚。我这里就不多做说明了。</p>\n</blockquote>\n<h3 id=\"使用-v-实现数据挂载（数据卷）\"><a href=\"#使用-v-实现数据挂载（数据卷）\" class=\"headerlink\" title=\"使用 -v 实现数据挂载（数据卷）\"></a>使用 <strong>-v 实现数据挂载（数据卷）</strong></h3><p>如果我们想在 run 一个新的mysql容器的时候，可以正常访问我们之前在mysql容器中创建的数据库、表数据，则在docker run命令启动容器的时候，就需要指定挂载目录。</p>\n<p><strong>注意：要想让新的mysql容器能正常挂载名称是“mysql”容器，前提是需要先停止名称是“mysql”的容器</strong>，不然的话，即使run命令配置正确，容器启动的时候会一直报错：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527547243072-cf5029a8-3d60-434f-aeba-f314633d6b0b.png\" alt=\"在Docker中安装Mysql\"></p>\n<p>上图就是因为没有事先停止mysql容器导致的。</p>\n<p><strong>下面开始具体操作：</strong></p>\n<ul>\n<li>先停止mysql容器</li>\n</ul>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527547465870-974cfc00-44b0-4a09-87a9-b6035b4adbf5.png\" alt=\"在Docker中安装Mysql\"></p>\n<ul>\n<li>重新启动一个新的mysql容器，命令如下：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql-v -v /var/lib/docker/volumes/1b0b17f6a4f78d357a187116d75991db8ee784213e67cc9b9988c8ef647fe563/_data:/var/lib/mysql mysql<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>最重要的一个参数 -v ：挂载数据卷。-v 后面的值中间有“：”号，前半部分指的是宿主机的目录（也就是我们上面的mysql容器的数据库存储的目录），后半部分指的是容器的目录。</p>\n<p>实现的效果就是说：新启动的容器，挂载宿主机的目录，实现数据共享。</p>\n</blockquote>\n<p>运行结果：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527547916774-cd6487ee-4afc-42a6-b6bb-f2ce6cf71523.png\" alt=\"在Docker中安装Mysql\"></p>\n<ul>\n<li><strong>登录新的mysql-v容器，查看数据库信息</strong></li>\n</ul>\n<p>直接看下图的命令操作吧：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527548344772-a86dd217-1ad4-4a19-b443-d51d2d45a80a.png\" alt=\"在Docker中安装Mysql\">       看到效果了吧！在这个mysql-v的新容器里面，已经可以看到我们一开始在“mysql”容器中创建的数据库和表了。</p>\n<p>也就实现了容器之间的数据共享。</p>\n<p>核心的实现就是在run命令里面加入了 -v 参数。如果不太明白-v的含义的，可以自行网上查询资料了解学习，加深印象。</p>\n<blockquote>\n<p><strong>上面我们解决了容器挂载数据卷的问题，但是细心的朋友，可能还有一个疑问：</strong></p>\n</blockquote>\n<p>为什么修改了my.cnf配置文件、以及运行mysql镜像时指定的MYSQL_ROOT_PASSWORD&#x3D;123456，却依然可以在新容器mysql-new中使用呢，为什么这俩样数据不会消失呢？</p>\n<blockquote>\n<p>官方文档对于commit命令还有这样一段描述：</p>\n<p>It can be useful to commit a container’s file changes or settings into a new image.</p>\n</blockquote>\n<p>谷歌翻译过来的意思就是：将容器的文件更改或设置提交到新映像可能很有用。</p>\n<p>还记得我们当初运行第一个mysql容器的时候，docker run 命令是怎样的，这里贴一下当时启动容器的命令：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --name=mysql mysql<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>其中，里面使用到了 -e 参数，设置了root用户的密码为123456。</p>\n<p>所以，结合官方文档对commit的介绍（It can be useful to commit a container’s file changes or settings into a new image. ），就可以知道，通过 -e 设置的信息，在使用commit提交新镜像的时候，这些设置被容器保留了下来，commit命令使用这些设置构建了新的镜像，在新容器里面使用的是相同的设置。</p>\n</blockquote>\n<blockquote>\n<p>这也印证了，我们在mysql-new容器中登录数据库的时候，登录密码写的是123456。因为在第一次启动mysql服务的时候，用户root密码是通过 -e 指定的，所以在commit提交新的镜像的时候，是被一同提交到了新镜像mysql-new中。</p>\n</blockquote>\n<h3 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h3><blockquote>\n<p>通过数据卷容器也可以实现多个容器间的数据共享。</p>\n</blockquote>\n<blockquote>\n<p>如果要授权一个容器访问另一个容器的数据卷，我们可以使用-volumes-from参数来执行docker run。</p>\n</blockquote>\n<p>（这里就不多做说明了，有兴趣的可以网上自行查阅资料研究）</p>\n",
            "tags": [
                "Docker",
                "LINUX"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(4)-%E5%AE%89%E8%A3%85Tomcat/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(4)-%E5%AE%89%E8%A3%85Tomcat/",
            "title": "Docker(4)-安装Tomcat",
            "date_published": "2023-05-28T13:00:29.384Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>本人文章均引用或者复制：</p>\n<p>公众号：</p>\n<p><img src=\"http://www.cicoding.cn/icons/wx.jpg\"></p>\n<p>QQ群：<a href=\"http://shang.qq.com/wpa/qunwpa?idkey=85cfa5c4c8fbe9859b7166a33d84c32f2def325c4d29f35f299a5756a955ab21\">806951874</a></p>\n</blockquote>\n<h1 id=\"在Docker中安装Tomcat\"><a href=\"#在Docker中安装Tomcat\" class=\"headerlink\" title=\"在Docker中安装Tomcat\"></a>在Docker中安装Tomcat</h1><h2 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p><strong>前言</strong></p>\n<p>Tomcat镜像中已经包含jdk环境依赖，所以我们可以不用去启动java容器，直接运行tomcat容器就可以正常访问tomcat服务的，当然，你启动了java容器，也不会有什么影响，因为容器之间是隔离的。</p>\n</blockquote>\n<h2 id=\"查询Tomcat镜像列表\"><a href=\"#查询Tomcat镜像列表\" class=\"headerlink\" title=\"查询Tomcat镜像列表\"></a>查询Tomcat镜像列表</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker search tomcat<br></code></pre></td></tr></table></figure>\n\n<p>运行结果如下图：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201010114436.png\"></p>\n<blockquote>\n<p>一般情况下，都会选择下载stars数量最多的那个镜像，排在第一位的，一般都是官方提供的镜像。</p>\n</blockquote>\n<h2 id=\"下载Tomcat镜像\"><a href=\"#下载Tomcat镜像\" class=\"headerlink\" title=\"下载Tomcat镜像\"></a>下载Tomcat镜像</h2><p>执行命令下载tomcat镜像：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull tomcat<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"运行Tomcat镜像\"><a href=\"#运行Tomcat镜像\" class=\"headerlink\" title=\"运行Tomcat镜像\"></a>运行Tomcat镜像</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -p 8081:8080 tomcat<br></code></pre></td></tr></table></figure>\n\n<p>运行效果如下图：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201010114658.png\"></p>\n<p>访问tomcat：</p>\n<blockquote>\n<p>访问地址为：ip:端口号，因为我的服务器地址为192.168.56.128，所以打开浏览器输入：<strong>192.168.56.128:8081</strong></p>\n<p>效果如下：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201010115113.png\"></p>\n</blockquote>\n<h2 id=\"运行Tomcat404问题\"><a href=\"#运行Tomcat404问题\" class=\"headerlink\" title=\"运行Tomcat404问题\"></a>运行Tomcat404问题</h2><blockquote>\n<p>解决docker启动tomcat容器访问端口显示404的问题，页面显示 源服务器未能找到目标资源的表示或者是不愿公开一个已经存在</p>\n</blockquote>\n<blockquote>\n<p><strong>如果已经关闭防火墙，还出现404问题，那么就确定是tomcat的webapps文件夹下没有东西</strong></p>\n</blockquote>\n<ul>\n<li><p>启动Tomcat容器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -p 8081:8080 tomcat<br></code></pre></td></tr></table></figure></li>\n<li><p>查看已经启动的容器</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker ps<br></code></pre></td></tr></table></figure></li>\n<li><p>访问部署环境地址</p>\n<blockquote>\n<p>使用8011端口访问Tomcat失败</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200228164338431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NTg5MDUw,size_16,color_FFFFFF,t_70\" alt=\"ip:端口号\"></p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"先查看防火墙状况\"><a href=\"#先查看防火墙状况\" class=\"headerlink\" title=\"先查看防火墙状况\"></a>先查看防火墙状况</h3><ul>\n<li><p>先查看防火墙状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">service firewalld status<br></code></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<p>出现下图所示代码，表示已经关闭防火墙</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200228164705354.png\" alt=\"在这里插入图片描述\"></p>\n</blockquote>\n<h4 id=\"防火墙未关闭\"><a href=\"#防火墙未关闭\" class=\"headerlink\" title=\"防火墙未关闭\"></a>防火墙未关闭</h4><blockquote>\n<p>如果防火墙没关闭，先关闭防火墙</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\"><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">关闭防火墙</span><br>systemctl stop firewalld.service<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">禁止防火墙开机启动</span><br>systemctl disable firewalld.service<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">启动docker</span><br>systemctl start docker<br><span class=\"hljs-meta prompt_\"># </span><span class=\"language-bash\">重启docker</span><br>systemctl restart docker<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"防火墙关闭\"><a href=\"#防火墙关闭\" class=\"headerlink\" title=\"防火墙关闭\"></a>防火墙关闭</h4><ul>\n<li><p>如果防火墙已经关闭但访问tomcat还是失败，那么使用如下命名进入tomcat的目录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker exec -it a5f02a3e6dde(启动的tomcat容器的容器id) /bin/bash<br></code></pre></td></tr></table></figure></li>\n<li><p>查看当前文件夹内的所有文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ls<br></code></pre></td></tr></table></figure></li>\n<li><p>进入webapps文件夹下，如果显示total 0，我们就需要把webapps.dist中的内容复制到webapps文件夹下</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">cd webapps<br>rm -f webapps<br>cp -r webapps.dist webapps<br></code></pre></td></tr></table></figure></li>\n<li><p>访问ip:主机端口（8081）</p>\n</li>\n</ul>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201010115113.png\" alt=\"img\"></p>\n<h2 id=\"后台运行Tomcat\"><a href=\"#后台运行Tomcat\" class=\"headerlink\" title=\"后台运行Tomcat\"></a>后台运行Tomcat</h2><blockquote>\n<p>通过上述步骤搭建一个Tomcat，是不是很简单，一个tomcat就这样启动完成了！不得不说docker的强大！</p>\n</blockquote>\n<blockquote>\n<p><strong>有没有觉得上面的启动方式存在什么问题？如果在命令行界面中按下 Ctrl+C快捷键，会有什么效果？</strong></p>\n<blockquote>\n<p>没错，当前的tomcat容器会停止运行，服务无法访问！</p>\n</blockquote>\n<p><strong>有什么办法可以让tomcat容器一直运行呢？</strong></p>\n<blockquote>\n<p>解决办法其实很简单，答案就再在 docker run 命令里面设置一个 -d 的参数即可，如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -d -p 8081:8080 --name tomcat tomcat<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201010164641.png\"></p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>看到没有，和上面的启动tomcat的效果不同，控制台并未输出tomcat启动的日志信息，这时候我们打开浏览器，重新访问一下：  <strong>192.168.56.128:8081</strong></p>\n<p>效果如下：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201010115113.png\" alt=\"img\"></p>\n</blockquote>\n<p>通过上面两次docker run 启动tomcat的效果对比，我想大家也应该看得出区别了。所以，如果想让应用在后台一直运行的话，通过在 docker run 命令中使用“-d”参数来让容器处于后台运行。</p>\n<h2 id=\"查看运行中的Tomcat容器\"><a href=\"#查看运行中的Tomcat容器\" class=\"headerlink\" title=\"查看运行中的Tomcat容器\"></a>查看运行中的Tomcat容器</h2><p>通过下面命令，来查看当前服务器上运行的docker容器列表：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker ps<br></code></pre></td></tr></table></figure>\n\n<p>如下图所示：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201010165054.png\"></p>\n<blockquote>\n<p>从图中可以看到tomcat容器的一些信息，在最后一列的“NAMES”显示的tomcat名称是“tomcat9”，这是因为你在docker run的时候，指定了“–name”别名，如果没有，docker会给你自动生成一个别名，一般情况下，我们还是建议使用–name来设置别名以及版本，方便实际使用容易区分。</p>\n<p>然后tomcat容器的“PORTS”这一列，可以看到8081 &gt; 8080 的信息，我们知道tomcat是运行在容器里面的，而tomcat默认的端口是8080，也就是说tomcat所在容器的对外端口是8080，我们如果想通过浏览器等访问到tomcat，就需要指定一个宿主机的端口与这个tomcat容器端口进行映射，也就是8081这个宿主机的端口。我们实际在浏览器访问的时候，就是通过8081来访问的，不能使用8080访问。端口号的话你也可以自定义的。</p>\n</blockquote>\n<h2 id=\"停止Tomcat容器\"><a href=\"#停止Tomcat容器\" class=\"headerlink\" title=\"停止Tomcat容器\"></a>停止Tomcat容器</h2><blockquote>\n<p>我们在jdk的文章中已经提及到停止容器的命令。</p>\n</blockquote>\n<p>首先我们还是要查看一下目前正在运行状态的tomcat容器的信息（ID或者别名）：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker ps<br></code></pre></td></tr></table></figure>\n\n<p>如下图：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201010165054.png\"></p>\n<blockquote>\n<p>我们可以看到tomcat容器的ID以及别名的信息，这里我就直接使用ID进行容器的操作了。</p>\n</blockquote>\n<p>通过docker stop实现容器停止关闭</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker stop tomcat9<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"疑问解答\"><a href=\"#疑问解答\" class=\"headerlink\" title=\"疑问解答\"></a>疑问解答</h2><h3 id=\"问题一\"><a href=\"#问题一\" class=\"headerlink\" title=\"问题一\"></a>问题一</h3><h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><blockquote>\n<p>之前启动了tomcat容器，最后又把它关闭了，那我如果想再运行这个tomcat服务，怎么办？难道是要重新执行docker run这个命令来运行一个tomcat容器吗？</p>\n</blockquote>\n<h4 id=\"解答\"><a href=\"#解答\" class=\"headerlink\" title=\"解答\"></a>解答</h4><blockquote>\n<p>我们要知道docker run这个命令的作用，其实是运行一个全新的容器。你执行一次docker run命令，就会生成一个新的容器，通过一个图来看一下具体情况：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527521919194-08e09ebc-778b-4f01-b5d0-bc9e229734da.png\" alt=\"在Docker中安装Tomcat\"><a href=\"http://www.cicoding.cn/images/docker/1527521919194-08e09ebc-778b-4f01-b5d0-bc9e229734da.png\">http://www.cicoding.cn/images/docker/1527521919194-08e09ebc-778b-4f01-b5d0-bc9e229734da.png</a></p>\n<p>从图中可以看到，出现了很多tomcat的容器，而且“STATUS”状态为“Exited”。什么意思呢？因为我在操作的过程中，总共执行了5次docker run命令（这里忽略docker rm删除的容器），启动了5个全新的容器，每个容器之间是隔离的。同时，我又对每个tomcat容器执行了docker stop关闭命令，所以状态都是“Exited”。</p>\n<p>所以，你每次启动的容器，docker都会给你保留下来，并不是说你执行了docker stop命令，容器就会被删除掉，答案是不会删除掉，只是标记一下容器的STATUS为Exited状态，处于未运行状态。</p>\n<p>所以，如果想重新运行关闭状态下的容器，请使用docker start命令，比如我这里随便启动一个tomcat容器：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker start 22<br></code></pre></td></tr></table></figure>\n\n<p>这时候通过docker ps查看处于运行状态的容器列表：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527522366260-fea95bcb-fced-4f46-8234-c8e39393a245.png\" alt=\"在Docker中安装Tomcat\"><a href=\"http://www.cicoding.cn/images/docker/1527522366260-fea95bcb-fced-4f46-8234-c8e39393a245.png\">http://www.cicoding.cn/images/docker/1527522366260-fea95bcb-fced-4f46-8234-c8e39393a245.png</a></p>\n<p>说明tomcat容器已经启动成功了！</p>\n<p>我们再通过docker ps -a查看所有的容器列表（包括未运行的容器），主要看一下tomcat容器的数量是否和上面的5个一致，并未重新运行一个全新的容器：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527522475276-0f83eb27-f7ef-4e5b-bcdc-39c32bdea54a.png\" alt=\"在Docker中安装Tomcat\"><a href=\"http://www.cicoding.cn/images/docker/1527522475276-0f83eb27-f7ef-4e5b-bcdc-39c32bdea54a.png\">http://www.cicoding.cn/images/docker/1527522475276-0f83eb27-f7ef-4e5b-bcdc-39c32bdea54a.png</a></p>\n<p>可以看到，tomcat容器的数量并未发生变化，其中的一个tomcat容器处于运行状态，剩余4个都是Exited停止状态。</p>\n</blockquote>\n<h3 id=\"问题二\"><a href=\"#问题二\" class=\"headerlink\" title=\"问题二\"></a>问题二</h3><h4 id=\"问题-1\"><a href=\"#问题-1\" class=\"headerlink\" title=\"问题\"></a>问题</h4><blockquote>\n<p>如果上图中代表当前服务器上的容器情况，如果这时候我执行以下命令，你觉得会出现什么问题？</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -d -p 8082:8080 --name quirky_mayer tomcat<br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>命令的含义应该都明白吧。启动一个新的tomcat容器，映射的宿主机端口号是8082（因为之前已经启动了一个8081的容器，宿主机的端口号不能冲突），给该tomcat容器起了一个别名“quirky_mayer”，注意观察一下上图的tomcat容器的别名信息哦~</p>\n</blockquote>\n<h4 id=\"解答-1\"><a href=\"#解答-1\" class=\"headerlink\" title=\"解答\"></a>解答</h4><blockquote>\n<p>运行结果如下图：<img src=\"http://www.cicoding.cn/images/docker/1527522929924-fbeab3d9-8623-4239-b816-d041b8da890a.png\" alt=\"在Docker中安装Tomcat\"><a href=\"http://www.cicoding.cn/images/docker/1527522929924-fbeab3d9-8623-4239-b816-d041b8da890a.png\">http://www.cicoding.cn/images/docker/1527522929924-fbeab3d9-8623-4239-b816-d041b8da890a.png</a></p>\n</blockquote>\n<blockquote>\n<p>其实错误信息很明显了，就是容器的别名“quirky_mayer”已经存在了，别的tomcat容器的别名也存在一个是“quirky_mayer”的。</p>\n<p>这个别名校验是否重复，是针对所有容器而言的，并非是只判断运行状态的容器，那些Exited状态的容器也会进行校验。</p>\n<p>因此，我们在使用–name指定别名的时候，不要出现重复。</p>\n</blockquote>\n",
            "tags": [
                "Docker",
                "LINUX"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(3)-%E5%AE%89%E8%A3%85jdk/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(3)-%E5%AE%89%E8%A3%85jdk/",
            "title": "Docker(3)-安装jdk",
            "date_published": "2023-05-28T13:00:29.383Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>本人文章均引用或者复制：</p>\n<p>公众号：</p>\n<p><img src=\"http://www.cicoding.cn/icons/wx.jpg\"></p>\n<p>QQ群：<a href=\"http://shang.qq.com/wpa/qunwpa?idkey=85cfa5c4c8fbe9859b7166a33d84c32f2def325c4d29f35f299a5756a955ab21\">806951874</a></p>\n</blockquote>\n<h1 id=\"在Docker中安装JDK\"><a href=\"#在Docker中安装JDK\" class=\"headerlink\" title=\"在Docker中安装JDK\"></a>在Docker中安装JDK</h1><blockquote>\n<p>所有的环境安装，都是在centos系统中操作的，并非本地windows系统。</p>\n</blockquote>\n<blockquote>\n<p>Docker 中国官方镜像加速 <a href=\"http://www.docker-cn.com/registry-mirror\">http://www.docker-cn.com/registry-mirror</a></p>\n</blockquote>\n<h2 id=\"获取JAVA镜像：\"><a href=\"#获取JAVA镜像：\" class=\"headerlink\" title=\"获取JAVA镜像：\"></a>获取JAVA镜像：</h2><blockquote>\n<p>在终端客户端命令行输入以下命令，获取JAVA镜像。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull java<br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>默认是从Docker Hub官方的仓库中下载镜像的。如果没有指定对应的版本，默认会获取版本为latest的镜像。</p>\n<p>注意：</p>\n<p>latest是针对于镜像所在的仓库里面的软件最新版本。并非是软件本身的最新发布版本。</p>\n</blockquote>\n<p>回车执行，一开始会进行下载对应的依赖库，稍作等待：<img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201006174731.png\" alt=\"QQ20201003-204338\"></p>\n<p>出现下面的信息，说明镜像下载完成：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201006174818.png\" alt=\"截屏2020-10-03 下午8.44.19\"></p>\n<h2 id=\"查看下载的镜像\"><a href=\"#查看下载的镜像\" class=\"headerlink\" title=\"查看下载的镜像\"></a>查看下载的镜像</h2><p>命令行中执行命令，查看刚刚下载的JAVA镜像：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker images<br></code></pre></td></tr></table></figure>\n\n<p>如下图所示：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201006174929.png\" alt=\"截屏2020-10-03 下午8.44.54\"></p>\n<h2 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h2><p>命令行中执行命令，启动JAVA镜像容器：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -d -it --name java java<br></code></pre></td></tr></table></figure>\n\n<p>如下图所示，说明成功启动了容器：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201006175022.png\" alt=\"截屏2020-10-03 下午8.46.03\"></p>\n<p>其中，–name后面的“java”是为容器指定了一个别名，而最后的那个“java”指的是下载镜像时的名称。</p>\n<blockquote>\n<p>命令以及参数的含义：</p>\n<p>run：启动一个镜像容器</p>\n<p>-d：指定容器运行于后台</p>\n<p>-it：-i 和 -t 的缩写；</p>\n<ul>\n<li>-i：以交互模式运行容器，通常与 -t 同时使用</li>\n<li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用</li>\n</ul>\n<p>–name：指定容器名字，后续可以通过名字进行容器管理</p>\n</blockquote>\n<p>具体更多的参数含义，可自行网上学习。</p>\n<h2 id=\"查看运行的容器\"><a href=\"#查看运行的容器\" class=\"headerlink\" title=\"查看运行的容器\"></a>查看运行的容器</h2><p>首先我们在命令行中执行命令，查看处于运行状态的容器：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker ps<br></code></pre></td></tr></table></figure>\n\n<p>因为在上面的操作步骤中，我们运行了java镜像，所以你会看到有一个名称为java的容器正在运行，如下图：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201006175118.png\" alt=\"截屏2020-10-03 下午8.46.37\"></p>\n<p>通过输出的信息可以看到，当前容器的ID是“9179eb86b007”，容器别名是java（最后一列的值）。</p>\n<h2 id=\"登录容器\"><a href=\"#登录容器\" class=\"headerlink\" title=\"登录容器\"></a>登录容器</h2><p>【询问】：如果想查看容器中安装的jdk版本，该怎么做呢？</p>\n<blockquote>\n<p>如果直接在命令行输入java -version会报错的，如下图：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527495437982-7aee34bf-9f5c-4ac5-8b8f-a3b21e9053c7.png\" alt=\"在Docker中安装JDK\"><a href=\"http://www.cicoding.cn/images/docker/1527495437982-7aee34bf-9f5c-4ac5-8b8f-a3b21e9053c7.png\">http://www.cicoding.cn/images/docker/1527495437982-7aee34bf-9f5c-4ac5-8b8f-a3b21e9053c7.png</a></p>\n<p>原因是因为：jdk是安装在容器里面的，需要进入容器，才能查看。意思就是说，jdk环境是在容器里面的，并非是宿主机。</p>\n</blockquote>\n<h3 id=\"进入容器内部\"><a href=\"#进入容器内部\" class=\"headerlink\" title=\"进入容器内部\"></a>进入容器内部</h3><ul>\n<li><strong>使用attach进入容器</strong></li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker attach 91<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>其中的 “91” 指的是什么呢？</p>\n</blockquote>\n<blockquote>\n<p>上面有提到过，我们启动的java镜像的容器ID是“9179eb86b007”，所以， docker attach 命令后面，你可以指定容器ID来进入具体的容器。可以指定06等任意长度的值，都代表了当前的java容器。</p>\n</blockquote>\n<blockquote>\n<p>回车，效果如下图：</p>\n</blockquote>\n<blockquote>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527495610202-3995506a-85ac-4a97-aeef-0edf11a8339a.png\" alt=\"在Docker中安装JDK\"><a href=\"http://www.cicoding.cn/images/docker/1527495610202-3995506a-85ac-4a97-aeef-0edf11a8339a.png\">http://www.cicoding.cn/images/docker/1527495610202-3995506a-85ac-4a97-aeef-0edf11a8339a.png</a></p>\n</blockquote>\n<blockquote>\n<p>如果回车后没有反应，可以再次按下回车就可以进入容器的命令行模式了。</p>\n</blockquote>\n<blockquote>\n<p>除了使用容器ID进入容器之外，也可以使用容器的别名进入容器：</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker attach java<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面这种是通过容器的别名进入容器内部的。</p>\n</blockquote>\n<ul>\n<li><strong>使用exec命令进入容器</strong></li>\n</ul>\n<blockquote>\n<p>【方式一】：通过容器别名进入容器：</p>\n</blockquote>\n<blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker exec -it java /bin/bash<br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>【方式二】：通过容器ID进入容器：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker exec -it 91 /bin/bash<br></code></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>回车之后，就会看到命令行发生了一些变化：</p>\n</blockquote>\n<blockquote>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527506181535-4364031d-0caa-44fe-8a12-d87ccf46c97e.png\" alt=\"在Docker中安装JDK\"><a href=\"http://www.cicoding.cn/images/docker/1527506181535-4364031d-0caa-44fe-8a12-d87ccf46c97e.png\">http://www.cicoding.cn/images/docker/1527506181535-4364031d-0caa-44fe-8a12-d87ccf46c97e.png</a></p>\n</blockquote>\n<blockquote>\n<p>仔细看第二行的开头，@符号后面的“9179eb86b007”就是我们的java容器的ID吧，这也就说明，我们已经进入了容器内部了，可以对容器进行操作了。</p>\n</blockquote>\n<h3 id=\"进入容器后，输入-java-version-查看JDK版本信息\"><a href=\"#进入容器后，输入-java-version-查看JDK版本信息\" class=\"headerlink\" title=\"进入容器后，输入 java -version 查看JDK版本信息\"></a>进入容器后，输入 java -version 查看JDK版本信息</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">java -version<br></code></pre></td></tr></table></figure>\n\n<p>无论是通过attach还是exec进入的容器，我们都可以在命令行中输入命令“java -version”来查看JDK版本信息。</p>\n<p>下面我们就分别使用这2个命令进入容器，来看看效果，如下图所示：</p>\n<ul>\n<li>attach命令进入容器，查看JDK版本信息</li>\n</ul>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527504069333-c1266217-f560-4a9d-b0d3-cac9f273dff0.png\" alt=\"在Docker中安装JDK\"><a href=\"http://www.cicoding.cn/images/docker/1527504069333-c1266217-f560-4a9d-b0d3-cac9f273dff0.png\">http://www.cicoding.cn/images/docker/1527504069333-c1266217-f560-4a9d-b0d3-cac9f273dff0.png</a></p>\n<ul>\n<li>exec命令进入容器，查看JDK版本信息</li>\n</ul>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527506442973-e6d97093-08df-46a7-89f8-7bd314c4733e.png\" alt=\"在Docker中安装JDK\"><a href=\"http://www.cicoding.cn/images/docker/1527506442973-e6d97093-08df-46a7-89f8-7bd314c4733e.png\">http://www.cicoding.cn/images/docker/1527506442973-e6d97093-08df-46a7-89f8-7bd314c4733e.png</a></p>\n<h3 id=\"登陆Docker容器的方式\"><a href=\"#登陆Docker容器的方式\" class=\"headerlink\" title=\"登陆Docker容器的方式\"></a>登陆Docker容器的方式</h3><blockquote>\n<p>上面已经简单的介绍了attach、exec命令的使用，下面讲解一下这两个命令之间的区别。</p>\n</blockquote>\n<blockquote>\n<p>对于运行在后台的Docker容器，我们运维人员时常是有登陆进去的需求。登陆Docker容器的方式：</p>\n</blockquote>\n<ul>\n<li>使用ssh登陆容器</li>\n</ul>\n<blockquote>\n<p>这种方法需要在容器中启动sshd，存在开销和攻击面增大的问题。同时也违反了Docker所倡导的一个容器一个进程的原则。</p>\n</blockquote>\n<ul>\n<li>使用自带命令docker attach登陆容器</li>\n</ul>\n<blockquote>\n<p>docker attach存在的问题是：当多个窗口同时attach到同一个容器时，所有的窗口都会同步的显示，假如其中的一个窗口发生阻塞时，其它的窗口也会阻塞，docker attach命令可以说是最不方便的进入后台docker容器的方法</p>\n</blockquote>\n<ul>\n<li>使用自带命令docker exec登陆容器</li>\n</ul>\n<blockquote>\n<p>docker exec和docker attach是Docker的原生方法，大多数情况下就使用这两种命令登陆容器。docker exec命令是在docker1.3之后出现的，比docker attach命令更加方便</p>\n</blockquote>\n<h3 id=\"分别使用attach与exec进入容器，查看它们的区别\"><a href=\"#分别使用attach与exec进入容器，查看它们的区别\" class=\"headerlink\" title=\"分别使用attach与exec进入容器，查看它们的区别\"></a>分别使用attach与exec进入容器，查看它们的区别</h3><p>1、Docker attach必须是登陆到一个已经运行的容器里。需要注意的是如果从这个容器中exit退出的话，就会导致容器停止！！这是极其不方便的！</p>\n<p>见下图所示结果：</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527507117875-46795fe1-3255-46c0-a2bc-6bde4b1e51dd.png\" alt=\"在Docker中安装JDK\"><a href=\"http://www.cicoding.cn/images/docker/1527507117875-46795fe1-3255-46c0-a2bc-6bde4b1e51dd.png\">http://www.cicoding.cn/images/docker/1527507117875-46795fe1-3255-46c0-a2bc-6bde4b1e51dd.png</a></p>\n<blockquote>\n<p>你会发现通过attach进入容器的话，当使用exit退出容器的时候，对应的容器也停止运行了，所以在生产环境中很少使用。</p>\n</blockquote>\n<p>2、docker exec登陆容器，注意有两个参数：-t和-i，这两个参数很重要！</p>\n<blockquote>\n<p>对于 -t 、-i 的具体作用，可以参考 <a href=\"https://www.cnblogs.com/kevingrace/p/6656095.html\">https://www.cnblogs.com/kevingrace/p/6656095.html</a></p>\n</blockquote>\n<blockquote>\n<p>使用docker exec -it 进入容器和我们平常操作console界面类似。而且不像attach方式退出，导致整个容器退出，exec在生产环境中用的比较多。exec 比使用ssh 、nsenter、nsinit方式更方便，生产中常用的方式。</p>\n</blockquote>\n<blockquote>\n<p>在使用docker exec登陆容器或执行容器中的命令时，最好都带上-t和-i参数。</p>\n</blockquote>\n<h2 id=\"退出Docker容器\"><a href=\"#退出Docker容器\" class=\"headerlink\" title=\"退出Docker容器\"></a>退出Docker容器</h2><ul>\n<li>如果是通过 attach 进入的容器，在退出容器的时候，如果不想让容器停止运行的话，就不能使用exit命令或者Ctrl+D快捷键的形式退出，而是使用 Ctrl + P + Q 组合键退出容器。</li>\n<li>如果是通过 exec 命令进入的容器，在退出容器的时候，就可以使用exit或者Ctrl+D快捷键退出容器，同时容器不会停止运行，这也是exec与attach的最大区别。当然，你也可以使用Ctrl + P + Q 组合键退出容器，容器一样不会停止运行。</li>\n</ul>\n<blockquote>\n<p>所以，通过上面的比较，也就印证了exec在实际使用过程中用的最多的，也是建议使用的一种方式。尤其是生产环境下，强烈建议使用exec的方式。</p>\n</blockquote>\n<h2 id=\"停止容器\"><a href=\"#停止容器\" class=\"headerlink\" title=\"停止容器\"></a>停止容器</h2><p>通过 docker stop (容器ID | 容器别名) 的命令，可以停止正在运行状态的容器：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">docker stop java<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面是通过容器别名来停止容器的，你也可以使用容器ID。</p>\n</blockquote>\n",
            "tags": [
                "Docker",
                "LINUX"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(2)-CentOS%E5%AE%89%E8%A3%85/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(2)-CentOS%E5%AE%89%E8%A3%85/",
            "title": "Docker(2)-CentOS安装",
            "date_published": "2023-05-28T13:00:29.383Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>本人文章均引用或者复制：</p>\n<p>公众号：</p>\n<p><img src=\"http://www.cicoding.cn/icons/wx.jpg\"></p>\n<p>QQ群：<a href=\"http://shang.qq.com/wpa/qunwpa?idkey=85cfa5c4c8fbe9859b7166a33d84c32f2def325c4d29f35f299a5756a955ab21\">806951874</a></p>\n</blockquote>\n<h1 id=\"在Centos系统中安装Docker\"><a href=\"#在Centos系统中安装Docker\" class=\"headerlink\" title=\"在Centos系统中安装Docker\"></a>在Centos系统中安装Docker</h1><h2 id=\"前言-1\"><a href=\"#前言-1\" class=\"headerlink\" title=\"前言\"></a>前言</h2><blockquote>\n<p>网上很多关于docker在centos系统上的安装教程，但是又各有异同，比较混乱。所以，此文章接下来的对于docker的安装，将参照官方的文档进行安装。</p>\n</blockquote>\n<blockquote>\n<p>官方文档地址：<a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\">https://docs.docker.com/install/linux/docker-ce/centos/</a></p>\n</blockquote>\n<h2 id=\"Docker版本\"><a href=\"#Docker版本\" class=\"headerlink\" title=\"Docker版本\"></a>Docker版本</h2><p>Docker如今划分成了2个版本：</p>\n<ul>\n<li>Docker CE（社区版）</li>\n<li>Docker EE（企业版）</li>\n</ul>\n<blockquote>\n<p>具体详情以及区别，就不多做说明了。我们一般都会选择Docker CE（社区版），因为CE版本是开源免费的。对于大多数企业公司都比较节约成本。</p>\n<p>因此，文章中所使用的Docker版本均为Docker CE版本。</p>\n</blockquote>\n<p>安装Docker CE版本的先决条件</p>\n<p>官方文档中有这样一段描述：</p>\n<blockquote>\n<figure class=\"highlight tex\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tex\">&gt;&gt; OS requirements<br>&gt;&gt; To install Docker CE, you need a maintained version of CentOS 7. Archived versions aren’t supported or tested.<br></code></pre></td></tr></table></figure>\n</blockquote>\n<p>翻译过来的中文意思就是：</p>\n<blockquote>\n<p>OS要求</p>\n<p>要安装Docker CE，您需要维护的CentOS 7版本。不支持或测试归档版本。</p>\n</blockquote>\n<p>官方推荐的系统是centos7以上，但其实centos6也是可以安装docker的，并没有强制必须是centos7。</p>\n<p>但是我的文章是基于最新的centos7系统，所以对于低版本的centos系统如何安装docker，请自行网上查找资料或者实际操作。</p>\n<p>卸载旧版本</p>\n<p>老版本的Docker被称为docker或docker-engine。如果安装了它们，请卸载它们以及相关的依赖项。</p>\n<p>在Linux命令行执行的命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">yum remove docker \\<br>                  docker-client \\<br>                  docker-client-latest \\<br>                  docker-common \\<br>                  docker-latest \\<br>                  docker-latest-logrotate \\<br>                  docker-logrotate \\<br>                  docker-selinux \\<br>                  docker-engine-selinux \\<br>                  docker-engine \\<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"安装Docker-CE\"><a href=\"#安装Docker-CE\" class=\"headerlink\" title=\"安装Docker CE\"></a>安装Docker CE</h2><p>Docker CE安装的不同方式</p>\n<ul>\n<li>设置Docker的存储库并从中进行安装，以便安装和升级任务。这是推荐的方法。</li>\n<li>有些用户下载RPM软件包并手动安装，并完全手动管理升级。这对于在无法访问互联网的系统上安装Docker等情况很有用。</li>\n<li>在测试和开发环境中，一些用户选择使用自动便利脚本来安装Docker。</li>\n</ul>\n<blockquote>\n<p>这里我们就选择第一种方式进行安装，这也是推荐的做法。</p>\n<p>至于其他的安装方式，可自行网上学习，这里不做过多讲解。</p>\n</blockquote>\n<p>使用存储库进行安装</p>\n<blockquote>\n<p>首次在新主机上安装Docker CE之前，需要设置Docker存储库。之后，您可以从存储库安装和更新Docker。</p>\n</blockquote>\n<p>设置存储库</p>\n<ul>\n<li>安装所需的包。 yum-utils提供yum-config-manager实用程序，devicemapper存储驱动程序需要device-mapper-persistent-data和lvm2。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">yum install -y yum-utils \\<br>  device-mapper-persistent-data \\<br>  lvm2 \\<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>使用以下命令设置稳定的存储库。 即使您想从边缘或测试存储库安装构建，也总是需要稳定的存储库。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">yum-config-manager \\<br>    --add-repo \\<br>    https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>（可选）：启用边缘和测试存储库。 这些存储库包含在上面的docker.repo文件中，但默认情况下处于禁用状态。 您可以将它们与稳定的存储库一起启用。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">yum-config-manager --enable docker-ce-edge<br>yum-config-manager --enable docker-ce-test<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>（可选）：与上一步相反的作用。通过使用–disable标志运行yum-config-manager命令，可以禁用边缘或测试存储库。 要重新启用它，请使用–enable标志。 以下命令禁用边缘存储库。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">yum-config-manager --disable docker-ce-edge<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p><strong>注意</strong>：从Docker 17.06开始，稳定版本也被推到<strong>边缘</strong>并<strong>测试</strong>版本库。</p>\n<p>了解稳定和边缘构建 :<a href=\"https://docs.docker.com/install/\">https://docs.docker.com/install/</a></p>\n</blockquote>\n<p>安装Docker CE</p>\n<ol>\n<li>安装最新版本的Docker CE：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">yum install docker-ce<br></code></pre></td></tr></table></figure>\n\n<p>如果命令行下面出现如下图所示的确认信息，请输入“y”继续，主要是用于处理依赖包的事情</p>\n<p><img src=\"http://www.cicoding.cn/images/docker/1527434165078-d4b449d2-24f3-4acc-90b1-033301c4fbce.png\" alt=\"在Centos系统中安装Docker\"></p>\n<p>如果没有，则需要添加yum源：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201002234210.png\" alt=\"QQ20201002-231329\"></p>\n<p>上一步输入“y”之后，后面可能会遇到下图所示的确认提示信息，同样的输入“y”即可：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201002234320.png\" alt=\"QQ20201002-231411\"></p>\n<p>稍作等待，当命令行最终输出“Complete！”即表示安装完成：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201002234614.png\" alt=\"QQ20201002-232659\"></p>\n<p>启动Docker</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl start docker<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"验证Docker是否安装成功\"><a href=\"#验证Docker是否安装成功\" class=\"headerlink\" title=\"验证Docker是否安装成功\"></a>验证Docker是否安装成功</h2><blockquote>\n<p>最简单的验证方式，就是使用 docker version 命令，类似于JDK的 java -version 一样的道理。</p>\n<p>Docker安装成功的话，就可以直接在命令行运行Docker的命令的。</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker version<br></code></pre></td></tr></table></figure>\n\n<p>如果出现如下图所示信息，说明Docker以及安装成功了！</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201003172941.png\" alt=\"QQ20201002-232747\"></p>\n<p>【可选】：当然，你也可以通过运行 hello-world 映像来检验Docker是否安装成功：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run hello-world<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>上面的命令含义：下载官方提供的用于测试使用的hello-world镜像并将其运行到容器中，来检验Docker服务是否正常安装并运行。</p>\n<p>执行上面的命令之后，Docker会自动下载hello-world镜像并自动运行到容器中，当命令行中出现“Hello from Docker!”的字样，说明已经成功运行了hello-world镜像，一切就OK了！</p>\n<p>这里就简单的作为Docker的入门操作，很简单的吧。让你有一个比较直观的感觉~</p>\n</blockquote>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201003201011.png\" alt=\"截屏2020-10-03 下午5.35.22\"></p>\n<h2 id=\"Docker默认挂载目录\"><a href=\"#Docker默认挂载目录\" class=\"headerlink\" title=\"Docker默认挂载目录\"></a>Docker默认挂载目录</h2><p>Docker CE安装成功之后，你可以发现 &#x2F;var&#x2F;lib 目录下有一个 docker 目录，你可以进入Docker目录查看Docker的一些结构，如下图所示：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201003201219.png\" alt=\"截屏2020-10-03 下午8.07.15\"></p>\n<p>其中有一个containers 目录，这个目录就是存放Docker容器的。上面我们有提及到 hello-world 镜像，如果你运行了 hello-world 镜像，那么这个镜像所生成的容器信息，就会存储在 containers 目录中。</p>\n<blockquote>\n<p>具体 containers 目录中存放了什么内容，可自行网上查询资料学习。</p>\n</blockquote>\n<h2 id=\"启动Docker\"><a href=\"#启动Docker\" class=\"headerlink\" title=\"启动Docker\"></a>启动Docker</h2><p>配置Docker在系统启动时启动</p>\n<p>未配置Docker在系统启动时启动，则系统重启之后，Docker服务是无法正常访问</p>\n<blockquote>\n<p>如何解决？</p>\n</blockquote>\n<blockquote>\n<p><strong>手动启动Docker服务：</strong></p>\n<blockquote>\n<p>通过在命令行中执行以下命令，即可实现Docker服务的启动：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl start docker<br></code></pre></td></tr></table></figure>\n\n<p>这时候重新在命令行中执行 docker version命令，效果如下：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201003201651.png\" alt=\"QQ20201002-232747\"></p>\n<p>出现Server相关的信息，标明Docker服务正常启动了，就可以对Docker进行一系列操作</p>\n<p>上面这种启动方式存在什么不足呢？</p>\n<p>当服务器重启的时候，Docker服务依然不能自动启动，还是需要手工去启动Docker服务。</p>\n<p>那能不能做到系统重启之后，Docker服务自动启动，答案肯定是有的。</p>\n</blockquote>\n<p>实现Docker服务随着系统重启后自动启动</p>\n<blockquote>\n<p>大多数当前的Linux发行版（RHEL，CentOS，Fedora，Ubuntu 16.04和更高版本）使用systemd来管理在系统启动时启动哪些服务。</p>\n<p>通过在命令行执行以下命令，用于设置Docker在系统重启时，自动启动Docker服务</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl enable docker<br></code></pre></td></tr></table></figure>\n\n<p>执行该命令之后，会显示如下结果：</p>\n<p><img src=\"https://gitee.com/yangxiangnanWorkSpace/uploadImages/raw/master/static/20201003202021.png\" alt=\"QQ20201002-232845\"></p>\n<p>主要的意思就是 设置Docker服务会随着服务器重启，会自动启动Docker服务。</p>\n<p>当然，执行该命令之后，对于当前的Docker服务状况是没有启动服务的，需要手动启动Docker服务；只有下次服务器重启，就无需手动启动Docker服务了。</p>\n<p>官方文档介绍：<a href=\"https://docs.docker.com/install/linux/linux-postinstall/#configure-docker-to-start-on-boot\">https://docs.docker.com/install/linux/linux-postinstall/#configure-docker-to-start-on-boot</a></p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>注意一点：由于Linux不同版本的系统的差异、或者低版本的系统，命令或许会出现差异。如有遇到这样的问题，请自行网上查找资料解决。</p>\n</blockquote>\n<h2 id=\"卸载Docker-CE\"><a href=\"#卸载Docker-CE\" class=\"headerlink\" title=\"卸载Docker CE\"></a>卸载Docker CE</h2><blockquote>\n<p>如果需要卸载机器上已经安装的Docker CE，可以通过简单命令实现。</p>\n</blockquote>\n<ol>\n<li>卸载Docker包：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">yum remove docker-ce<br></code></pre></td></tr></table></figure>\n\n<ol>\n<li>上面的命令，不会自动删除主机上的图像，容器，卷或自定义配置文件。要想删除所有图像，容器和卷，执行以下命令：</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">rm -rf /var/lib/docker<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：必须手动删除任何已编辑的配置文件</p>\n</blockquote>\n<h2 id=\"shell一键安装\"><a href=\"#shell一键安装\" class=\"headerlink\" title=\"shell一键安装\"></a>shell一键安装</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">curl -fsSL get.docker.com -o get-docker.sh<br>sudo sh get-docker.sh<br></code></pre></td></tr></table></figure>\n\n<p>这样执行完了就完成安装了，简单便捷</p>\n<p>然后启动docker</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo systemctl start docker<br></code></pre></td></tr></table></figure>\n",
            "tags": [
                "Docker",
                "LINUX"
            ]
        },
        {
            "id": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(1)-%E5%88%9D%E8%AF%86Docker/",
            "url": "https://github.com/yangxiangnanwill/yangxiangnanwill.github.io/2023/05/28/%E5%A5%BD%E5%A5%BD%E7%A0%81%E4%BB%A3%E7%A0%81%E5%90%96/Docker/Docker(1)-%E5%88%9D%E8%AF%86Docker/",
            "title": "Docker(1)-初识Docker",
            "date_published": "2023-05-28T13:00:29.382Z",
            "content_html": "<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>本人文章均引用或者复制：</p>\n<p>公众号：</p>\n<p><img src=\"http://www.cicoding.cn/icons/wx.jpg\"></p>\n<p>QQ群：<a href=\"http://shang.qq.com/wpa/qunwpa?idkey=85cfa5c4c8fbe9859b7166a33d84c32f2def325c4d29f35f299a5756a955ab21\">806951874</a></p>\n</blockquote>\n<h1 id=\"Docker的前世今生\"><a href=\"#Docker的前世今生\" class=\"headerlink\" title=\"Docker的前世今生\"></a>Docker的前世今生</h1><h2 id=\"传统项目开发部署的流程是怎样的？\"><a href=\"#传统项目开发部署的流程是怎样的？\" class=\"headerlink\" title=\"传统项目开发部署的流程是怎样的？\"></a>传统项目开发部署的流程是怎样的？</h2><h3 id=\"传统项目开发部署的基本流程\"><a href=\"#传统项目开发部署的基本流程\" class=\"headerlink\" title=\"传统项目开发部署的基本流程\"></a>传统项目开发部署的基本流程</h3><p>这里只简单描述一下，项目发布的基本流程</p>\n<ul>\n<li>本地开发+测试，没有问题的话，编译打包发布到测试环境</li>\n<li>在测试环境中进行测试，测试完成后，发布到生产环境</li>\n<li>在生产环境中进行最后的测试，如果没有问题，那么一切就OK了</li>\n</ul>\n<h3 id=\"存在什么问题？\"><a href=\"#存在什么问题？\" class=\"headerlink\" title=\"存在什么问题？\"></a>存在什么问题？</h3><ul>\n<li><strong>存在问题：不同机器上的软件环境不一致。（比较核心的问题)</strong></li>\n<li><strong>软件环境的配置繁多、命令记不清楚。</strong></li>\n<li><strong>重复性搭建软件环境、效率低下。</strong></li>\n</ul>\n<h2 id=\"对照传统虚拟机总结\"><a href=\"#对照传统虚拟机总结\" class=\"headerlink\" title=\"对照传统虚拟机总结\"></a>对照传统虚拟机总结</h2><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>容器</th>\n<th>虚拟机</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>启动</td>\n<td>秒级</td>\n<td>分钟级</td>\n</tr>\n<tr>\n<td>硬盘使用</td>\n<td>一般为MB</td>\n<td>一般为GB</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>接近原生</td>\n<td>弱于</td>\n</tr>\n<tr>\n<td>系统支持量</td>\n<td>单机支持上千个容器</td>\n<td>一般几十个</td>\n</tr>\n</tbody></table>\n<h1 id=\"Docker是干什么用的？\"><a href=\"#Docker是干什么用的？\" class=\"headerlink\" title=\"Docker是干什么用的？\"></a>Docker是干什么用的？</h1><h2 id=\"Docker解决的问题\"><a href=\"#Docker解决的问题\" class=\"headerlink\" title=\"Docker解决的问题\"></a>Docker解决的问题</h2><p>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。<br>Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其它机器上。</p>\n<p><img src=\"https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2520176274,3530821872&fm=26&gp=0.jpg\"></p>\n<h2 id=\"与虚拟机的比较\"><a href=\"#与虚拟机的比较\" class=\"headerlink\" title=\"与虚拟机的比较\"></a>与虚拟机的比较</h2><p>虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。</p>\n<p>so</p>\n<blockquote>\n<p>&#x3D;&#x3D;<strong>Docker不是虚拟机</strong>&#x3D;&#x3D;</p>\n</blockquote>\n<blockquote>\n<p>对Docker的感受：</p>\n</blockquote>\n<p>比如公司买了一台新服务器，系统是centos，你要想把项目部署到服务器上，而且项目中使用到了mysql、redis、activemq、zookeeper等技术，要想项目能在服务器上正常运行，必须在新的服务器上搭建好mysql、redis、activemq、zookeeper服务环境。这样的话，在环境搭建和配置上就要花费太多的时间了（因为需要配置很多的配置文件、需要手动启动服务等）。</p>\n<p>又或者每次重装一次系统或者换一个机器，你就要把环境重装一次，东西越多花费的时间越多、很麻烦、浪费时间和精力。</p>\n<p>而使用Docker的话，你只需要一条命令，你就可以在你的centos系统上运行你需要的软件，比如mysql、tomcat、jdk、redis等。</p>\n<blockquote>\n<p>举个栗子</p>\n</blockquote>\n<p>【示例1】：Docker上安装mysql</p>\n<ul>\n<li>你需要MySQL服务，那么在docker中通过简单的命令就可以安装一个MySQL数据库服务：</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull mysql<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>启动mysql命令</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 mysql<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>很简单吧，一个mysql服务就启动完成了，就可以正常使用了。可以通过mysql客户端（Navicat、DataGrip等）连接这个mysql数据库。</p>\n</blockquote>\n<p>【示例2】：Docker上安装jdk</p>\n<ul>\n<li>你需要JDK环境，那么在Docker中通过简单的命令安装一个JDK的镜像， 然后通过一条命令启动这个容器就行了，容器会自动给你安装配置好JDK环境。</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">docker pull java<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>就这么简单的一条命令，JDK就安装好了。你可以在Docker容器的命令行中通过java -version来检测jdk是否安装成功。</p>\n</blockquote>\n<blockquote>\n<p><strong>镜像、容器</strong>：</p>\n<p>对于新手而言，或许有点不明白镜像和容器分别是个什么东东，还是有点不明白。</p>\n<p>你可以这样感官的理解：</p>\n<blockquote>\n<p>镜像 —— 相当于ISO操作系统的安装包，ISO镜像的内容是固定的，不会发生改变，可以重复使用。</p>\n<p>容器 —— 类似于使用 ISO镜像安装的新的操作系统，可以使用一个相同的ISO镜像，安装很多操作系统。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<p>Docker占用的资源很小。启动一个容器一般都是秒级的。</p>\n</blockquote>\n<h1 id=\"Docker镜像、容器、仓库的介绍\"><a href=\"#Docker镜像、容器、仓库的介绍\" class=\"headerlink\" title=\"Docker镜像、容器、仓库的介绍\"></a>Docker镜像、容器、仓库的介绍</h1><h2 id=\"Docker镜像\"><a href=\"#Docker镜像\" class=\"headerlink\" title=\"Docker镜像\"></a>Docker镜像</h2><p>通俗的理解镜像</p>\n<blockquote>\n<p>Docker的镜像是一个只读的模板，一个独立的文件系统，包括运行容器所需的数据，可以用来创建新的容器。</p>\n</blockquote>\n<p>Docker的镜像相当于ISO操作系统的安装包，ISO镜像的内容是固定的，不会发生改变，可以重复使用。</p>\n<p>如果上面的形容还无法让你理解Docker镜像，那我再举一个例子：</p>\n<p>从事Java开发的人都知道类和实例的关系。直观的感觉，类就像是一个模板，根据这个类模板，可以生成很多个具体的对象实例。</p>\n<p>则，<strong>Docker镜像就相当于Java的类，而通过Docker镜像生成出来的东西，我们就叫他它“容器”</strong>。</p>\n<p>通过上面的形容，应该可以感觉的到镜像和容器之间的关系了吧。</p>\n<h2 id=\"Docker容器\"><a href=\"#Docker容器\" class=\"headerlink\" title=\"Docker容器\"></a>Docker容器</h2><p>通俗的理解容器</p>\n<p>在上一节已经介绍了镜像与容器的关系。</p>\n<p>这里就直接copy文档中的一句话，来简单形容一下容器：</p>\n<p><strong>Docker镜像就相当于Java的类，而通过Docker镜像生成出来的东西，我们就叫他它“容器”</strong>。</p>\n<h2 id=\"Docker仓库\"><a href=\"#Docker仓库\" class=\"headerlink\" title=\"Docker仓库\"></a>Docker仓库</h2><p>通俗的理解Docker仓库</p>\n<p>仓库支持的操作类似git，当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。</p>\n<p>类似于，将某项目模块打成jar包，然后上传到私有或者公有的maven仓库，然后在其他的所有支持maven环境的机器上，都可以拉取这个jar进行使用。</p>\n",
            "tags": [
                "Docker",
                "LINUX"
            ]
        }
    ]
}